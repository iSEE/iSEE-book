[
["index.html", "Extending iSEE Preface", " Extending iSEE Kevin Rue-Albrecht, Federico Marini, Charlotte Soneson, and Aaron Lun 2019-12-29 Preface The Bioconductor iSEE package provides functions for creating an interactive graphical user interface (GUI) using the RStudio Shiny package for exploring data stored in SummarizedExperiment objects, including row- and column-level metadata (Rue-Albrecht et al. 2018). In this book we describe how to create web-applications that leverage builtin panels and develop new ones. References "],
["panels.html", "Chapter 1 Panel classes 1.1 Overview 1.2 The Panel class 1.3 The DotPlot and Table panel families 1.4 The ColumnDotPlot and RowDotPlot panel families 1.5 Built-in ColumnDotPlot panel classes 1.6 Built-in RowDotPlot panel classes 1.7 The ColumnTable and RowTable panel families 1.8 Built-in ColumnTable panel classes 1.9 Built-in RowTable panel classes 1.10 The HeatMapPlot panel class", " Chapter 1 Panel classes 1.1 Overview The types of panels available to compose an iSEE app are defined as a hierarchy of S4 classes. Panel* DotPlot* ColumnDotPlot* RedDimPlot ColDataPlot FeatAssayPlot RowDotPlot* RowDataPlot SampAssayPlot Table* RowTable* RowStatTable ColumnTable* ColStatTable HeatMapPlot Some of those classes are “virtual” (indicated by *), meaning that they cannot be directly instanciated as panels in the GUI. Instead, virtual panel classes define families of panels that share groups of properties. Virtual classes are meant to be used as the parent of one or more concrete classes. In contrast, concrete classes must define fully-functional panels that can be embedded in a GUI, interact with other panels, receive and process data, and generate an output such as a plot or a table, accompanied by a code chunk to display in the code tracker for reproducibility. 1.2 The Panel class The top-most class is called Panel. It is a virtual class that defines the core properties common to any panel - existing or future - that may be displayed in the interface. PanelId Integer index indicating the ith panel of a given type. PanelHeight Height of the panel, in pixels. PanelWidth Width of the panel, an integer value indicating the number of columns to use, from 1 to 12. SelectBoxOpen Logical value indicating if the Selection parameters box of the panel is open when the app starts. SelectByPlot Encoded name of the panel from which to receive a selection of data points. SelectMultiType Keyword indicating the method to deal with multiple incoming selections of data points. SelectMultiSaved Integer index indicating a single data point selection to use, among multiple incoming selections. 1.3 The DotPlot and Table panel families The Panel virtual class is directly derived into two major virtual sub-classes: DotPlot Table Those classes introduce properties that are specific to distinct subsets of panel types. The DotPlot class introduce parameters specific to panels where the output is a ggplot object and each row in the data-frame is represented as a point in a plot. The Table class introduce parameters specific to panels where the main output is a data-frame directly displayed as a table in the GUI. In addition, the HeatMapPlot class defines a special panel class that directly extends the Panel class, as it introduces a set of parameters distinct from both the DotPlot and Table panel families. This panel type is described in further details in a separate section below. 1.4 The ColumnDotPlot and RowDotPlot panel families 1.5 Built-in ColumnDotPlot panel classes 1.6 Built-in RowDotPlot panel classes 1.7 The ColumnTable and RowTable panel families 1.8 Built-in ColumnTable panel classes 1.9 Built-in RowTable panel classes 1.10 The HeatMapPlot panel class This type of panel introduces parameters specific to panels where the output is a heat map, with each row representing a feature and each column representing a sample in the se object. "],
["server.html", "Chapter 2 The app server 2.1 Reactive objects 2.2 Persistent (non-reactive) objects 2.3 The app memory 2.4 The panel API 2.5 Initialization of the app server", " Chapter 2 The app server 2.1 Reactive objects 2.2 Persistent (non-reactive) objects 2.3 The app memory The app memory is a list of instances created from available panel classes, which defines the order in which individual panels are displayed in the GUI. 2.4 The panel API 2.4.1 .cacheCommonInfo Each individual panel type (e.g., Reduced dimension plot) and family of panel types (e.g., Column dot plot) defines a .cacheCommonInfo function. This function is called for each panel instance in memory when the app is initialized. It allows the app to efficienly compute a single time common information that only depends on the input se object, and may be frequently reused during the runtime of the app. Following the hierarchy of panel types, each call to the signature takes a panel instance x and the se object, and caches common information relevant to all instances of that panel type in the se object itself, before calling callNextMethod() to invoke the next parent signature. The top-most signature - for the Panel class - returns the se object that contains all the cached information. Note that this function only populates the cache for the first panel of each type; it is a no-op if the common cache has already been initialized. 2.4.2 .refineParameters Each individual panel type (e.g., Reduced dimension plot) and family of panel types (e.g., Column dot plot) defines a .refineParameters function. This function is called for each panel instance in memory when the app is initialized, and also when a new panel is added to the GUI. It inspects the parameters of a given panel instance, and replaces invalid parameters with sensible values for a given se object. Following the hierarchy of panel types, each call to the signature takes an instance x and the se object, and first calls callNextMethod() to invoke the next parent signature, to refine generic parameters before processing specific ones. The called signature ultimately returns the updated instance panel x, or NULL if the panel instance is not available for this app. 2.5 Initialization of the app server The app server is initialized as soon as a valid se object is provided. This can be either in the call to iSEE(se) or using the Shiny file upload button in apps that were launched without providing the se arguments, e.g., iSEE(). The initialize_server function takes the se object and the list holding reactive values used to trigger re-rendering of the GUI, as described above. The very first step invokes the function .sanitize_SE_input on the se object. This function coerces the se to SingleCellExperiment, flattens nested DataFrames, adds row and column names, and removes other non-atomic fields. In addition, it also sanitizes the SingleCellExperiment object by moving internal fields into the column- or row-level metadata, making them visible in the Column statistics table and Row statistics table panels, respectively. The function returns both the sanitized se object that will be used by the app, and the list of R commands that will be displayed in the code tracker for users. Next, the server invokes the checkColormapCompatibility function. This function takes the se object and the optioanl colormap provided to iSEE(), and carries out a number of compatibility checks between the two objects. The function collects a character vector of issue messages that are displayed - if any - as warning messages in GUI during initialization. Next, the .cacheCommonInfo and .refineParameters are successively invoked on each panel instance initialized in the app memory. As described in a separate section above, the first function precomputes and caches information specific to the se object and frequently used throughout the runtime of the app. The second function ensures that each panel instance is initialized with valid parameters; it replaces any invalid parameters with sensible values for a given se object. Next, persistent (non-reactive) objects are initialized: the app memory (see this section) the count of panels of each type, used to assign increasing ID to new panel instances the list of commands to display in the code tracker for each panel instance the list of data point coordinates selectable in each panel instance1 a list of miscellaneous cached information2 Data points downsampled for rendering speed performance remain selectable, even though they are not visible in the plot.↩ The plot that contain the legend keys of Heatmap panels is currently cached as miscellaneous information retrieved separately when rendering the GUI.↩ "],
["plotting.html", "Chapter 3 The plotting API 3.1 .getPlottingFunction", " Chapter 3 The plotting API 3.1 .getPlottingFunction Each panel type available for use in the GUI defines a .getPlottingFunction. This function is called within .createRenderedOutput, which is triggered by observers when the value of the panel input widgets are changed by users, or when a new panel is added to the GUI. The .getPlottingFunction function inspects the parameters for a given panel instance, and uses the app memory of all active panels and parameters, the coordinates of data points in each plot panel, the se object, and the colormap to generate all the information necessary to render the outputs of this panel and those that depend on it. For DotPlot panels, the output is a list that includes: the list of commands to display in the code tracker the coordinates of data points in the plot the ggplot object For Table panels, the output is a datatable. For the HeatMap panel, the function does not return any value. Instead it sets relevant elements in the output object of the Shiny session. "],
["developing.html", "Chapter 4 Developing new panels", " Chapter 4 Developing new panels First things first, we need to load the iSEE package for this chapter. library(iSEE) "],
["the-panel-api.html", "Chapter 5 The panel API 5.1 Create a new S4 class", " Chapter 5 The panel API Fully functional panel class must implement - or inherit from their parent class - the full set of methods that composes the API allowing panels to interact and communicate with the reactive infrastructure of iSEE applications. a validity method, defined using setValidity2. .fullName, used to generate a unique full name uniquely identifying each panel instance in the GUI. .cacheCommonInfo, computing and caching static information about a SummarizedExperiment object regularly used by other API methods. initialize, creating a new panel instance with panel settings initialized with empty default values .refineParameters, replacing invalid panel settings with appropriate values. .defineInterface, used to define panel-specific Shiny widgets receiving user inputs in the GUI. .createObservers, used to define reactive functions that update internal reactive objects following user interactions. .getCommandsDataXY, used to generate commands and labels related to the x-axis and y-axis of panel classes producing a plot output. 5.1 Create a new S4 class In the chapter Panel classes, we saw how each type of panel is defined as an S4 class, organised in a hierarchy that allows new panel classes to inherit sets of the properties and functionality from parent classes. Therefore, developing a new panel starts with the creation of a new class. While it is possible to create a new panel class from scratch, this is an advanced use case described in a separate section. Instead, new panels classes can be much more rapidly derived from a parent panel class, using the inheritance relationships between classes to reuse properties and functionality defined in the parent class. The choice of a parent class for the new panel depends on the properties that we want that new panel to have. For instance, let us say that we want to define a new panel that has all the functionality of the Reduced dimension plot panel type, but summarizes data into a layer of hexagonal bins instead of showing each individual data point. To start, we declare our new class with a new unique name, e.g. RedDimHexbinPlot, that contains the builtin panel class RedDimPlot. setClass(&quot;RedDimHexbinPlot&quot;, contains=&quot;RedDimPlot&quot;) "],
["references.html", "References", " References "],
["case-study-i.html", "Chapter 6 Case study I 6.1 Overview 6.2 Class basics 6.3 Setting up the interface 6.4 Creating the observers 6.5 Making the plot 6.6 Finishing touches 6.7 In action", " Chapter 6 Case study I 6.1 Overview In this case study, we will create a custom panel class to regenerate sample-level PCA coordinates using only a subset of points transmitted as a multiple column selection from another panel. We call this a dynamic reduced dimension plot, as it is dynamically recomputing the dimensionality reduction results rather than using pre-computed values in the reducedDims() slot of a SingleCellExperiment object. 6.2 Class basics First, we define the basics of our new Panel class. As our new class will be showing each sample as a point, we inherit from the ColumnDotPlot virtual class. This automatically gives us access to all the functionality promised in the contract, including interface elements and observers to handle multiple selections and respond to aesthetic parameters. library(iSEE) setClass(&quot;DynRedDimPlot&quot;, contains=&quot;ColumnDotPlot&quot;, slots=c(NGenes=&quot;integer&quot;, Type=&quot;character&quot;)) We add a slot specifying the type of dimensionality reduction result and the number of highly variable genes to use. Any new slots should also come with validity methods, as shown below. library(S4Vectors) setValidity2(&quot;DynRedDimPlot&quot;, function(object) { msg &lt;- character(0) if (length(n &lt;- object[[&quot;NGenes&quot;]])!=1L || n &lt; 1L) { msg &lt;- c(msg, &quot;&#39;NGenes&#39; must be a positive integer scalar&quot;) } if (!isSingleString(val &lt;- object[[&quot;Type&quot;]]) || !val %in% c(&quot;PCA&quot;, &quot;TSNE&quot;, &quot;UMAP&quot;)) { msg &lt;- c(msg, &quot;&#39;Type&#39; must be one of &#39;TSNE&#39;, &#39;PCA&#39; or &#39;UMAP&#39;&quot;) } if (length(msg)) { return(msg) } TRUE }) ## Class &quot;DynRedDimPlot&quot; [in &quot;.GlobalEnv&quot;] ## ## Slots: ## ## Name: NGenes Type ColorByColData ## Class: integer character character ## ## Name: ColorByFeatNameAssay ColorBySampNameColor ShapeByColData ## Class: character character character ## ## Name: SizeByColData FacetByRow FacetByColumn ## Class: character character character ## ## Name: ColorBy ColorByDefaultColor ColorByFeatName ## Class: character character character ## ## Name: ColorByRowTable ColorBySampName ColorByColTable ## Class: character character character ## ## Name: ShapeBy SizeBy SelectEffect ## Class: character character character ## ## Name: SelectColor SelectAlpha ZoomData ## Class: character numeric numeric ## ## Name: BrushData VisualBoxOpen VisualChoices ## Class: list logical character ## ## Name: ContourAdd ContourColor PointSize ## Class: logical character numeric ## ## Name: PointAlpha Downsample SampleRes ## Class: numeric logical numeric ## ## Name: FontSize LegendPosition PanelId ## Class: numeric character integer ## ## Name: PanelHeight PanelWidth SelectBoxOpen ## Class: integer integer logical ## ## Name: SelectRowSource SelectColSource DataBoxOpen ## Class: character character logical ## ## Name: SelectRowType SelectRowSaved SelectColType ## Class: character integer character ## ## Name: SelectColSaved MultiSelectHistory ## Class: integer list ## ## Extends: ## Class &quot;ColumnDotPlot&quot;, directly ## Class &quot;DotPlot&quot;, by class &quot;ColumnDotPlot&quot;, distance 2 ## Class &quot;Panel&quot;, by class &quot;ColumnDotPlot&quot;, distance 3 It is also worthwhile specializing the initialize() method to provide a default for new parameters: setMethod(&quot;initialize&quot;, &quot;DynRedDimPlot&quot;, function(.Object, Type=&quot;PCA&quot;, NGenes=1000L, ...) { callNextMethod(.Object, Type=Type, NGenes=NGenes, ...) }) 6.3 Setting up the interface The most basic requirement is to define some methods that describe our new panel in the iSEE() interface. This includes defining the full name and desired default color for display purposes: setMethod(&quot;.fullName&quot;, &quot;DynRedDimPlot&quot;, function(x) &quot;Dynamic reduced dimension plot&quot;) setMethod(&quot;.panelColor&quot;, &quot;DynRedDimPlot&quot;, function(x) &quot;#0F0F0F&quot;) We also add interface elements to change the result type and the number of genes. This is most easily done by specializing the .defineDataInterface method: library(shiny) setMethod(&quot;.defineDataInterface&quot;, &quot;DynRedDimPlot&quot;, function(x, se, select_info) { plot_name &lt;- .getEncodedName(x) list( selectInput(paste0(plot_name, &quot;_Type&quot;), label=&quot;Dimensionality reduction Type&quot;, choices=c(&quot;PCA&quot;, &quot;TSNE&quot;, &quot;UMAP&quot;), selected=x[[&quot;Type&quot;]]), numericInput(paste0(plot_name, &quot;_NGenes&quot;), label=&quot;Number of genes&quot;, min=1, value=x[[&quot;NGenes&quot;]]) ) }) We call .getEncodedName() to obtain a unique name for the current instance of our panel, e.g., DynRedDimPlot1. We then paste0 the name of our panel to the name of any parameter to ensure that the ID is unique to this instance of our panel; otherwise, multiple DynRedDimPlots would override each other. One can imagine this as a poor man’s Shiny module. 6.4 Creating the observers We specialize .createObservers to define some observers to respond to changes in our new interface elements. Note the use of callNextMethod() to ensure that observers of the parent class are also created; this automatically ensures that we can respond to changes in parameters provided by ColumnDotPlot. setMethod(&quot;.createObservers&quot;, &quot;DynRedDimPlot&quot;, function(x, se, input, session, pObjects, rObjects) { callNextMethod() plot_name &lt;- .getEncodedName(x) # TODO: expose .define_protected_parameter_observers for developer use, # which would allow these steps to be a one-liner. type_field &lt;- paste0(plot_name, &quot;_Type&quot;) observeEvent(input[[type_field]], { previous &lt;- pObjects$memory[[plot_name]][[&quot;Type&quot;]] if (identical(previous, input[[type_field]])) { return(NULL) } pObjects$memory[[plot_name]][[&quot;Type&quot;]] &lt;- input[[type_field]] .requestCleanUpdate(plot_name, pObjects, rObjects) }) num_field &lt;- paste0(plot_name, &quot;_NGenes&quot;) observeEvent(input[[num_field]], { previous &lt;- pObjects$memory[[plot_name]][[&quot;NGenes&quot;]] if (identical(previous, input[[num_field]])) { return(NULL) } pObjects$memory[[plot_name]][[&quot;NGenes&quot;]] &lt;- input[[num_field]] .requestCleanUpdate(plot_name, pObjects, rObjects) }) }) Both the NGenes and Type parameters are what we consider to be “protected” parameters, as changing them will alter the nature of the displayed plot. By using .requestCleanUpdate(), we instruct iSEE() to destroy existing brushes and lassos when these parameters are changed, as brushes/lassos made on the previous plot do not make sense when the coordinates are recomputed. 6.5 Making the plot When working with a ColumnDotPlot subclass, the easiest way to change plotting content to override the .generateDotPlotData method. This should add a plot.data variable to the envir environment that has columns X and Y and contains one row per column of the original SummarizedExperiment. It should also return a character vector of R commands describing how that plot.data object was constructed. The easiest way to do this is to create a character vector of commands and call eval(parse(text=...), envir=envir) to evaluate them within envir. setMethod(&quot;.generateDotPlotData&quot;, &quot;DynRedDimPlot&quot;, function(x, envir) { commands &lt;- character(0) if (!exists(&quot;col_selected&quot;, envir=envir, inherits=FALSE)) { commands &lt;- c(commands, &quot;plot.data &lt;- data.frame(X=numeric(0), Y=numeric(0));&quot;) } else { commands &lt;- c(commands, &quot;.chosen &lt;- unique(unlist(col_selected));&quot;, &quot;set.seed(100000)&quot;, # to avoid problems with randomization. sprintf(&quot;.coords &lt;- scater::calculate%s(se[,.chosen], ntop=%i, ncomponents=2);&quot;, x[[&quot;Type&quot;]], x[[&quot;NGenes&quot;]]), &quot;plot.data &lt;- data.frame(.coords, row.names=.chosen);&quot;, &quot;colnames(plot.data) &lt;- c(&#39;X&#39;, &#39;Y&#39;);&quot; ) } commands &lt;- c(commands, &quot;plot.data &lt;- plot.data[colnames(se),,drop=FALSE];&quot;, &quot;rownames(plot.data) &lt;- colnames(se);&quot;) eval(parse(text=commands), envir=envir) list(data_cmds=commands, plot_title=sprintf(&quot;Dynamic %s plot&quot;, x[[&quot;Type&quot;]]), x_lab=paste0(x[[&quot;Type&quot;]], &quot;1&quot;), y_lab=paste0(x[[&quot;Type&quot;]], &quot;2&quot;)) }) We use functions from the scater package to do the actual heavy lifting of calculating the dimensionality reduction results. The exists() call will check whether any column selection is being transmitted to this panel; if not, it will just return a plot.data variable that contains all NAs such that an empty plot is created. If col_selected does exist, it contains a list of character vectors specifying the active and saved multiple selections that are being transmitted. In this case, we do not care about the distinctin between active/saved selections so we just take the union of all of them. Of course, this is not quite the most efficient way to implement a plotting panel that involves recomputation. A better approach would be to cache the x/y coordinates and reuse them if only aesthetic parameters have changed, thus avoiding an unnecessary delay from recomputation. Doing so requires overriding .renderOutput() to take advantage of the cached contents of the plot, so for simplicity, we will not do that here. 6.6 Finishing touches For this particular panel class, an additional helpful feature is to override .multiSelectionInvalidated. This indicates that any brushes or lassos in our plot should be destroyed when we receive a new column selection. Doing so is the only sensible course of action as the reduced dimension coordinates for one set of samples have no obvious relationship to the coordinates for another set of samples; having old brushes or lassos hanging around would be of no benefit at best, and be misleading at worst. setMethod(&quot;.multiSelectionInvalidated&quot;, &quot;DynRedDimPlot&quot;, function(x) TRUE) 6.7 In action Let’s put our new panel to the test. We set up an example using our favorite dataset, creating a SingleCellExperiment object with some precomputed dimensionality reduction results. library(scRNAseq) sce &lt;- ReprocessedAllenData(assays=&quot;tophat_counts&quot;) ## No internet connection using &#39;localHub=TRUE&#39; ## snapshotDate(): 2019-12-17 ## see ?scRNAseq and browseVignettes(&#39;scRNAseq&#39;) for documentation ## loading from cache ## see ?scRNAseq and browseVignettes(&#39;scRNAseq&#39;) for documentation ## loading from cache ## see ?scRNAseq and browseVignettes(&#39;scRNAseq&#39;) for documentation ## loading from cache library(scater) ## Loading required package: ggplot2 sce &lt;- logNormCounts(sce, exprs_values=&quot;tophat_counts&quot;) sce &lt;- runPCA(sce, ncomponents=4) sce &lt;- runTSNE(sce) The plan is to create a (fixed) reduced dimension plot that will transmit to our dynamic reduced dimension plot. Setting up the iSEE instance is as easy as: rdp &lt;- RedDimPlot(PanelId=1L) drdp &lt;- new(&quot;DynRedDimPlot&quot;, SelectColSource=&quot;RedDimPlot1&quot;) app &lt;- iSEE(sce, initial=list(rdp, drdp)) Brushing at any location in the RedDimPlot will trigger dynamically recompution of results in our DynRedDimPlot. "],
["case-study-ii.html", "Chapter 7 Case study II 7.1 Overview 7.2 Class basics 7.3 Setting up the interface 7.4 Creating the observers 7.5 Making the table 7.6 In action", " Chapter 7 Case study II 7.1 Overview In this case study, we will create a panel class to dynamically compute differential expression (DE) statistics between the active sample-level selection and the other saved selections from a transmitting panel. 7.2 Class basics First, we define the basics of our new Panel class. As our new class will be showing each gene as a row, we inherit from the RowTable virtual class. This automatically gives us access to all the functionality promised in the contract, including interface elements and observers to respond to multiple selections. We also add a slot specifying the log-fold change threshold to use in the null hypothesis. library(iSEE) setClass(&quot;DGETable&quot;, contains=&quot;RowTable&quot;, slots=c(LogFC=&quot;numeric&quot;)) Any new slots should come with validity methods, as shown below. library(S4Vectors) setValidity2(&quot;DGETable&quot;, function(object) { msg &lt;- character(0) if (length(val &lt;- object[[&quot;LogFC&quot;]])!=1L || val &lt; 0) { msg &lt;- c(msg, &quot;&#39;NGenes&#39; must be a non-negative number&quot;) } if (length(msg)) { return(msg) } TRUE }) ## Class &quot;DGETable&quot; [in &quot;.GlobalEnv&quot;] ## ## Slots: ## ## Name: LogFC Selected Search ## Class: numeric character character ## ## Name: SearchColumns PanelId PanelHeight ## Class: character integer integer ## ## Name: PanelWidth SelectBoxOpen SelectRowSource ## Class: integer logical character ## ## Name: SelectColSource DataBoxOpen SelectRowType ## Class: character logical character ## ## Name: SelectRowSaved SelectColType SelectColSaved ## Class: integer character integer ## ## Name: MultiSelectHistory ## Class: list ## ## Extends: ## Class &quot;RowTable&quot;, directly ## Class &quot;Table&quot;, by class &quot;RowTable&quot;, distance 2 ## Class &quot;Panel&quot;, by class &quot;RowTable&quot;, distance 3 It is also worthwhile specializing the initialize() method to provide a default for new parameters. We hard-code the SelectColType setting as we want to obtain all multiple selections from the transmitting panel, in order to be able to perform pairwise DE analyses between the various active and saved selections. (By comparison, the default of \"Active\" will only transmit the current active selection.) setMethod(&quot;initialize&quot;, &quot;DGETable&quot;, function(.Object, LogFC=0, ...) { callNextMethod(.Object, LogFC=LogFC, SelectColType=&quot;Union&quot;, ...) }) 7.3 Setting up the interface The most basic requirement is to define some methods that describe our new panel in the iSEE() interface. This includes defining the full name and desired default color for display purposes: setMethod(&quot;.fullName&quot;, &quot;DGETable&quot;, function(x) &quot;Differential expression table&quot;) setMethod(&quot;.panelColor&quot;, &quot;DGETable&quot;, function(x) &quot;#AAFF00&quot;) We also add interface elements to change the result type and the number of genes. This is most easily done by specializing the .defineDataInterface method: library(shiny) setMethod(&quot;.defineDataInterface&quot;, &quot;DGETable&quot;, function(x, se, select_info) { plot_name &lt;- .getEncodedName(x) list( numericInput(paste0(plot_name, &quot;_LogFC&quot;), label=&quot;Log-FC threshold&quot;, min=0, value=x[[&quot;LogFC&quot;]]) ) }) As we discussed before, we paste0 the name of our panel to the name of any parameter to ensure that the ID is unique to this instance of our panel. 7.4 Creating the observers We specialize .createObservers to define some observers to respond to changes in our new interface elements. Note the use of callNextMethod() to ensure that observers of the parent class are also created; this automatically ensures that we can respond to changes in parameters provided by RowTable. setMethod(&quot;.createObservers&quot;, &quot;DGETable&quot;, function(x, se, input, session, pObjects, rObjects) { callNextMethod() plot_name &lt;- .getEncodedName(x) num_field &lt;- paste0(plot_name, &quot;_LogFC&quot;) observeEvent(input[[num_field]], { previous &lt;- pObjects$memory[[plot_name]][[&quot;LogFC&quot;]] if (identical(previous, input[[num_field]])) { return(NULL) } pObjects$memory[[plot_name]][[&quot;LogFC&quot;]] &lt;- input[[num_field]] .requestUpdate(plot_name, rObjects) }) }) The distinction between protected and unprotected parameters is less important for Tables; as long as the types of the columns do not change between renderings, any column or global selections (i.e., search terms) are usually still sensible. 7.5 Making the table When working with a RowTable subclass, the easiest way to change plotting content to override the .generateTable method. This is expected to generate a data.frame in the evaluation environment, returning the commands required to do so. In this case, we want to perform one-sided \\(t\\)-tests between the active selection and any number of saved selections. We will use the findMarkers() function from scran to compute the desired statistics. This performs all pairwise comparisons, so is not as efficient as could be, but it will suffice for this demonstration. setMethod(&quot;.generateTable&quot;, &quot;DGETable&quot;, function(x, envir) { empty &lt;- &quot;tab &lt;- data.frame(Top=integer(0), p.value=numeric(0), FDR=numeric(0));&quot; if (!exists(&quot;col_selected&quot;, envir, inherits=FALSE) || length(envir$col_selected)&lt;2L || !&quot;active&quot; %in% names(envir$col_selected)) { commands &lt;- empty } else { commands &lt;- c(&quot;.chosen &lt;- unlist(col_selected);&quot;, &quot;.grouping &lt;- rep(names(col_selected), lengths(col_selected));&quot;, sprintf(&quot;.de.stats &lt;- scran::findMarkers(logcounts(se)[,.chosen], .grouping, direction=&#39;up&#39;, lfc=%s)&quot;, x[[&quot;LogFC&quot;]]), &quot;tab &lt;- as.data.frame(.de.stats[[&#39;active&#39;]]);&quot; ) } eval(parse(text=commands), envir=envir) list(commands=commands, contents=envir$tab) }) Readers may notice that we prefix internal variables with . in our commands. This ensures that they do not clash with global variables created by iSEE() itself (which is not an issue when running the app, but makes things difficult when the code is reported for tracking purposes). 7.6 In action Let’s put our new panel to the test. We set up an example using our favorite dataset, creating a SingleCellExperiment object with some precomputed dimensionality reduction results. library(scRNAseq) sce &lt;- ReprocessedAllenData(assays=&quot;tophat_counts&quot;) ## No internet connection using &#39;localHub=TRUE&#39; ## snapshotDate(): 2019-12-17 ## see ?scRNAseq and browseVignettes(&#39;scRNAseq&#39;) for documentation ## loading from cache ## see ?scRNAseq and browseVignettes(&#39;scRNAseq&#39;) for documentation ## loading from cache ## see ?scRNAseq and browseVignettes(&#39;scRNAseq&#39;) for documentation ## loading from cache library(scater) sce &lt;- logNormCounts(sce, exprs_values=&quot;tophat_counts&quot;) sce &lt;- runPCA(sce, ncomponents=4) sce &lt;- runTSNE(sce) The plan is to create a (fixed) reduced dimension plot that will transmit to our DGE table. Setting up the iSEE instance is as easy as: rdp &lt;- RedDimPlot(PanelId=1L, SelectBoxOpen=TRUE) dget &lt;- new(&quot;DGETable&quot;, SelectColSource=&quot;RedDimPlot1&quot;) app &lt;- iSEE(sce, initial=list(rdp, dget)) Brushing (or lassoing) at any location and saving the selection will trigger dynamic recompution of results in our DGETable. We can repeat this with any number of saved selections. "]
]
