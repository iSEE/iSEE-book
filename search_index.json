[
["index.html", "Extending iSEE Preface", " Extending iSEE Kevin Rue-Albrecht, Federico Marini, Charlotte Soneson, and Aaron Lun 2020-02-08 Preface The Bioconductor package iSEE provides functions for creating an interactive graphical user interface (GUI) using the RStudio Shiny package for exploring data stored in SummarizedExperiment objects, including row- and column-level metadata (Rue-Albrecht et al. 2018). In this book we describe how to create web-applications that leverage builtin panels and develop new ones. We also present case studies to illustrate the development of custom panels. References "],
["panels.html", "Chapter 1 Panel classes 1.1 Overview 1.2 The Panel class 1.3 The DotPlot and Table panel families 1.4 The ColumnDotPlot and RowDotPlot panel families 1.5 Built-in ColumnDotPlot panel classes 1.6 Built-in RowDotPlot panel classes 1.7 The ColumnTable and RowTable panel families 1.8 Built-in ColumnTable panel classes 1.9 Built-in RowTable panel classes 1.10 The HeatMapPlot panel class", " Chapter 1 Panel classes 1.1 Overview The types of panels available to compose an iSEE app are defined as a hierarchy of S4 classes. Panel* DotPlot* ColumnDotPlot* RedDimPlot ColDataPlot FeatAssayPlot RowDotPlot* RowDataPlot SampAssayPlot Table* RowTable* RowStatTable ColumnTable* ColStatTable HeatMapPlot Some of those classes are “virtual” (indicated by *), meaning that they cannot be directly instanciated as panels in the GUI. Instead, virtual panel classes define families of panels that share groups of properties. Virtual classes are meant to be used as the parent of one or more concrete classes. In contrast, concrete classes must define fully-functional panels that can be embedded in a GUI, interact with other panels, receive and process data, and generate an output such as a plot or a table, accompanied by a code chunk to display in the code tracker for reproducibility. 1.2 The Panel class The top-most class is called Panel. It is a virtual class that defines the core properties common to any panel - existing or future - that may be displayed in the interface. Refer to help(\"Panel-class\") for more information about the slots and methods provided by this core class. 1.3 The DotPlot and Table panel families The Panel virtual class is directly derived into two major virtual sub-classes: DotPlot Table Those classes introduce properties that are specific to distinct subsets of panel types. The DotPlot class introduces parameters specific to panels where the output is a ggplot object and each row in the data-frame is represented as a point in a plot. The Table class introduces parameters specific to panels where the main output is a data-frame directly displayed as a table in the GUI. In addition, the HeatMapPlot class defines a special concrete panel class that directly extends the Panel class, as it introduces a set of parameters distinct from both the DotPlot and Table panel families. This panel type is described in further details in a separate section below. 1.4 The ColumnDotPlot and RowDotPlot panel families 1.5 Built-in ColumnDotPlot panel classes 1.6 Built-in RowDotPlot panel classes 1.7 The ColumnTable and RowTable panel families 1.8 Built-in ColumnTable panel classes 1.9 Built-in RowTable panel classes 1.10 The HeatMapPlot panel class This type of panel introduces parameters specific to panels where the output is a heat map, with each row representing a feature and each column representing a sample in the se object. "],
["api.html", "Chapter 2 The panel API 2.1 .cacheCommonInfo 2.2 .refineParameters 2.3 .generateDotPlot", " Chapter 2 The panel API 2.1 .cacheCommonInfo Each individual panel type (e.g., Reduced dimension plot) and family of panel types (e.g., Column dot plot) defines a .cacheCommonInfo function. This function is called for each panel instance in memory when the app is initialized. It allows the app to efficiently compute a single time common information that only depends on the input se object, and may be frequently reused during the runtime of an app. Following the hierarchy of panel types, each call to the signature takes a panel instance x and the se object, and caches common information relevant to all instances of that panel type in the se object itself, before calling callNextMethod() to invoke the next parent signature. The top-most signature - for the Panel class - returns the se object that contains all the cached information. Note that this function only populates the cache for the first panel of each type; it is a no-op if the common cache has already been initialized. 2.2 .refineParameters Each individual panel type (e.g., Reduced dimension plot) and family of panel types (e.g., Column dot plot) defines a .refineParameters function. This function is called for each panel instance in memory when the app is initialized, and also when a new panel is added to the GUI. It inspects the parameters of a given panel instance, and replaces invalid parameters with sensible values for a given se object. Following the hierarchy of panel types, each call to the signature takes an instance x and the se object, and first calls callNextMethod() to invoke the next parent signature, to refine generic parameters before processing specific ones. The called signature ultimately returns the updated instance panel x, or NULL if the panel instance is not available for this app. 2.3 .generateDotPlot Each panel type that derives from the virtual class DotPlot must define - or inherits - the .generateDotPlot method. This function is called within .renderOutput, which is triggered by observers when the value of the input widgets are changed by users, or when a new panel is added to the GUI. The .generateDotPlot function has access to the parameters for a given panel instance, and uses information available in the panel evaluation environment to generate and evaluate the plotting commands that ultimately produce the ggplot object to display in the panel. Refer to the “Generating the ggplot object” section of help(\".generateDotPlot\") for more information. "],
["server.html", "Chapter 3 The app server 3.1 Reactive objects 3.2 Persistent (non-reactive) objects 3.3 The app memory 3.4 Initialization of the app server", " Chapter 3 The app server 3.1 Reactive objects 3.2 Persistent (non-reactive) objects 3.3 The app memory The app memory is a list of instances created from available panel classes, which defines the order in which individual panels are displayed in the GUI. 3.4 Initialization of the app server The app server is initialized as soon as a valid se object is provided. This can be either in the call to iSEE(se) or using the Shiny file upload button in apps that were launched without providing the se arguments, e.g., iSEE(). The initialize_server function takes the se object and the list holding reactive values used to trigger re-rendering of the GUI, as described above. The very first step invokes the function .sanitize_SE_input on the se object. This function coerces the se to SingleCellExperiment, flattens nested DataFrames, adds row and column names, and removes other non-atomic fields. In addition, it also sanitizes the SingleCellExperiment object by moving internal fields into the column- or row-level metadata, making them visible in the Column statistics table and Row statistics table panels, respectively. The function returns both the sanitized se object that will be used by the app, and the list of R commands that will be displayed in the code tracker for users. Next, the server invokes the checkColormapCompatibility function. This function takes the se object and the optioanl colormap provided to iSEE(), and carries out a number of compatibility checks between the two objects. The function collects a character vector of issue messages that are displayed - if any - as warning messages in GUI during initialization. Next, the .cacheCommonInfo and .refineParameters are successively invoked on each panel instance initialized in the app memory. As described in a separate section above, the first function precomputes and caches information specific to the se object and frequently used throughout the runtime of the app. The second function ensures that each panel instance is initialized with valid parameters; it replaces any invalid parameters with sensible values for a given se object. Next, persistent (non-reactive) objects are initialized: the app memory (see this section) the count of panels of each type, used to assign increasing ID to new panel instances the list of commands to display in the code tracker for each panel instance the list of data point coordinates selectable in each panel instance1 a list of miscellaneous cached information2 Data points downsampled for rendering speed performance remain selectable, even though they are not visible in the plot.↩ The plot that contain the legend keys of Heatmap panels is currently cached as miscellaneous information retrieved separately when rendering the GUI.↩ "],
["developing.html", "Chapter 4 Developing new panels 4.1 Create a new S4 class 4.2 Add a constructor function 4.3 Set the panel name in the GUI 4.4 Define the commands generating a plot output", " Chapter 4 Developing new panels First, we need to load the iSEE package for this chapter. This action imports all the builtin panel class definitions, including the virtual class Panel that is the base class for any iSEE panel class. library(iSEE) We also set up an example using our favorite dataset, creating a SingleCellExperiment object with some precomputed dimensionality reduction results. library(scRNAseq) sce &lt;- ReprocessedAllenData(assays=&quot;tophat_counts&quot;) library(scater) sce &lt;- logNormCounts(sce, exprs_values=&quot;tophat_counts&quot;) sce &lt;- runPCA(sce, ncomponents=4) sce &lt;- runTSNE(sce) 4.1 Create a new S4 class In the chapter Panel classes, we saw how each type of panel is defined as an S4 class, organised in a hierarchy that allows new panel classes to inherit sets of the properties and functionality from parent classes. Then, developing a new panel type starts with the creation of a new class that inherits from the Panel class. While it is possible to create a new panel class that directly inherits from the top-most virtual Panel class, this is the most advanced use case that we will describe in a later section. Instead, new concrete panels classes can be rapidly derived from other concrete parent panel classes, using the inheritance relationships between classes to reuse properties and functionality defined in all of the parent classes. The choice of a parent class for the new panel depends on the properties that we want that new panel to have. For instance, to create a panel that inherits all the functionality of the Reduced dimension plot panel type, we simply define a new class that extends the RedDimPlot class. We call that new class RedDimHexPlot. setClass(&quot;RedDimHexPlot&quot;, contains=&quot;RedDimPlot&quot;) 4.2 Add a constructor function At this point, it is possible to create instances of the new panel class already. To facilitate this, new panels should provide a constructor function - named identically to the class - to accept arbitrary arguments controlling the initialization of new panel instances created by the new function. Here, we define a simple constructor function that passes all incoming arguments to the new function as is. RedDimHexPlot &lt;- function(...) { new(&quot;RedDimHexPlot&quot;, ...) } At this point, we can already use instances of this new panel class in iSEE apps. RedDimHexPlot1 &lt;- RedDimHexPlot() initial &lt;- list(RedDimHexPlot1) app &lt;- iSEE(sce, initial = initial) However, that would not be very exciting as instances of this new panel class would behave exactly like the those of the RedDimPlot class. RedDimHexPlot1 &lt;- RedDimHexPlot() RedDimPlot1 &lt;- RedDimPlot() initial &lt;- list(RedDimHexPlot1, RedDimPlot1) app &lt;- iSEE(sce, initial = initial) 4.3 Set the panel name in the GUI The panel class that we created so far also inherited the name of the parent panel class. In other words, instances of both classes are indistinguishable from each other in the GUI. The name of each panel displayed in the GUI is defined by the .fullName method. To clearly distinguish the new panel class in the GUI, we overwrite this method to display a name different from the parent class. setMethod(&quot;.fullName&quot;, &quot;RedDimHexPlot&quot;, function(x) &quot;Reduced dimension hexagonal plot&quot;) With that, running app again now highlights how panels of the new class now display a different title from the parent class. 4.4 Define the commands generating a plot output Importantly, the API separates the generation of commands processing data from sce into a data-frame, from the generation of commands producing a ggplot object using the processed data-frame. If a new DotPlot panel class is meant to process data in the same way as its parent panel, only to display in a different way, it is then possible to overwrite only the .generateDotPlot method. Meanwhile, the data preprocessing will be implicitly handled by the other API methods inherited from the parent class. Importantly, the .generateDotPlot method requires two key arguments: labels provides the plot labels for each of the aesthetics in the plot data, and envir provides the environment in which the plotting commands are to be evaluated to produce the ggplot object. In particular, .generateDotPlot can rely on certain environment variables promised by the contract. Above all, those include plot.data, the data-frame that contains one row per data point to display. Using those environment variables, .generateDotPlot can make decisions altering the plotting commands and the resulting ggplot object. We invite readers to refer to the “Generating the ggplot object” section of help(\".generateDotPlot\") for more information. As an example, we overwrite the .generateDotPlot function for the new RedDimHexPlot class to simply show the number of data point in the plotting area as a heatmap dividing the plane into regular hexagons. Notably, the function can immediately rely on the plot.data data-frame that is computed by methods defined for the parent class RedDimPlot. We also use the precomputed aesthetic labels associated with each column of plot.data, while setting a fixed \"Count\" label for the fill aesthetic associated with the count of observation in each hexagonal bin. setMethod(&quot;.generateDotPlot&quot;, &quot;RedDimHexPlot&quot;, function(x, labels, envir) { stopifnot(require(ggplot2)) plot_cmds &lt;- list() plot_cmds[[&quot;ggplot&quot;]] &lt;- &quot;ggplot() +&quot; # Adding hexbins to the plot. plot_cmds[[&quot;hex&quot;]] &lt;- &quot;geom_hex(aes(X, Y), plot.data) +&quot; plot_cmds[[&quot;labs&quot;]] &lt;- &quot;labs(fill=&#39;Count&#39;) +&quot; plot_cmds[[&quot;labs&quot;]] &lt;- sprintf( &quot;labs(x=&#39;%s&#39;, y=&#39;%s&#39;, title=&#39;%s&#39;, fill=&#39;%s&#39;) +&quot;, labels$X, labels$Y, labels$title, &quot;Count&quot; ) plot_cmds[[&quot;theme_base&quot;]] &lt;- &quot;theme_bw() +&quot; plot_cmds[[&quot;theme_legend&quot;]] &lt;- &quot;theme(legend.position = &#39;bottom&#39;)&quot; gg_plot &lt;- eval(parse(text=plot_cmds), envir) list(plot=gg_plot, commands=plot_cmds) }) Running app again highlights how the RedDimHexPlot panel fills each hexagonal bin with a color indicating the number of data points present in the corresponding area in the RedDimPlot panel. "],
["dynamic-reduced-dimensions.html", "Chapter 5 Dynamic reduced dimensions 5.1 Overview 5.2 Class basics 5.3 Setting up the interface 5.4 Creating the observers 5.5 Making the plot 5.6 Finishing touches 5.7 In action", " Chapter 5 Dynamic reduced dimensions 5.1 Overview In this case study, we will create a custom panel class to regenerate sample-level PCA coordinates using only a subset of points transmitted as a multiple column selection from another panel. We call this a dynamic reduced dimension plot, as it is dynamically recomputing the dimensionality reduction results rather than using pre-computed values in the reducedDims() slot of a SingleCellExperiment object. 5.2 Class basics First, we define the basics of our new Panel class. As our new class will be showing each sample as a point, we inherit from the ColumnDotPlot virtual class. This automatically gives us access to all the functionality promised in the contract, including interface elements and observers to handle multiple selections and respond to aesthetic parameters. We add a slot specifying the type of dimensionality reduction result and the number of highly variable genes to use. Any new slots should also come with validity methods, as shown below. library(S4Vectors) setValidity2(&quot;DynRedDimPlot&quot;, function(object) { msg &lt;- character(0) if (length(n &lt;- object[[&quot;NGenes&quot;]])!=1L || n &lt; 1L) { msg &lt;- c(msg, &quot;&#39;NGenes&#39; must be a positive integer scalar&quot;) } if (!isSingleString(val &lt;- object[[&quot;Type&quot;]]) || !val %in% c(&quot;PCA&quot;, &quot;TSNE&quot;, &quot;UMAP&quot;)) { msg &lt;- c(msg, &quot;&#39;Type&#39; must be one of &#39;TSNE&#39;, &#39;PCA&#39; or &#39;UMAP&#39;&quot;) } if (length(msg)) { return(msg) } TRUE }) It is also worthwhile specializing the initialize() method to provide a default for new parameters: setMethod(&quot;initialize&quot;, &quot;DynRedDimPlot&quot;, function(.Object, Type=&quot;PCA&quot;, NGenes=1000L, ...) { callNextMethod(.Object, Type=Type, NGenes=NGenes, ...) }) 5.3 Setting up the interface The most basic requirement is to define some methods that describe our new panel in the iSEE() interface. This includes defining the full name and desired default color for display purposes: setMethod(&quot;.fullName&quot;, &quot;DynRedDimPlot&quot;, function(x) &quot;Dynamic reduced dimension plot&quot;) setMethod(&quot;.panelColor&quot;, &quot;DynRedDimPlot&quot;, function(x) &quot;#0F0F0F&quot;) We also add interface elements to change the result type and the number of genes. This is most easily done by specializing the .defineDataInterface method: library(shiny) setMethod(&quot;.defineDataInterface&quot;, &quot;DynRedDimPlot&quot;, function(x, se, select_info) { plot_name &lt;- .getEncodedName(x) list( selectInput(paste0(plot_name, &quot;_Type&quot;), label=&quot;Type:&quot;, choices=c(&quot;PCA&quot;, &quot;TSNE&quot;, &quot;UMAP&quot;), selected=x[[&quot;Type&quot;]]), numericInput(paste0(plot_name, &quot;_NGenes&quot;), label=&quot;Number of HVGs:&quot;, min=1, value=x[[&quot;NGenes&quot;]]) ) }) We call .getEncodedName() to obtain a unique name for the current instance of our panel, e.g., DynRedDimPlot1. We then paste0 the name of our panel to the name of any parameter to ensure that the ID is unique to this instance of our panel; otherwise, multiple DynRedDimPlots would override each other. One can imagine this as a poor man’s Shiny module. 5.4 Creating the observers We specialize .createObservers to define some observers to respond to changes in our new interface elements. Note the use of callNextMethod() to ensure that observers of the parent class are also created; this automatically ensures that we can respond to changes in parameters provided by ColumnDotPlot. setMethod(&quot;.createObservers&quot;, &quot;DynRedDimPlot&quot;, function(x, se, input, session, pObjects, rObjects) { callNextMethod() plot_name &lt;- .getEncodedName(x) .createProtectedParameterObservers(plot_name, fields=c(&quot;Type&quot;, &quot;NGenes&quot;), input=input, pObjects=pObjects, rObjects=rObjects) }) Both the NGenes and Type parameters are what we consider to be “protected” parameters, as changing them will alter the nature of the displayed plot. We use the .createProtectedParameterObservers() utility to set up observers for both parameters, which will instruct iSEE() to destroy existing brushes and lassos when these parameters are changed. The idea here is that brushes/lassos made on the previous plot do not make sense when the coordinates are recomputed. 5.5 Making the plot When working with a ColumnDotPlot subclass, the easiest way to change plotting content to override the .generateDotPlotData method. This should add a plot.data variable to the envir environment that has columns X and Y and contains one row per column of the original SummarizedExperiment. It should also return a character vector of R commands describing how that plot.data object was constructed. The easiest way to do this is to create a character vector of commands and call eval(parse(text=...), envir=envir) to evaluate them within envir. setMethod(&quot;.generateDotPlotData&quot;, &quot;DynRedDimPlot&quot;, function(x, envir) { commands &lt;- character(0) if (!exists(&quot;col_selected&quot;, envir=envir, inherits=FALSE)) { commands &lt;- c(commands, &quot;plot.data &lt;- data.frame(X=numeric(0), Y=numeric(0));&quot;) } else { commands &lt;- c(commands, &quot;.chosen &lt;- unique(unlist(col_selected));&quot;, &quot;set.seed(100000)&quot;, # to avoid problems with randomization. sprintf(&quot;.coords &lt;- scater::calculate%s(se[,.chosen], ntop=%i, ncomponents=2);&quot;, x[[&quot;Type&quot;]], x[[&quot;NGenes&quot;]]), &quot;plot.data &lt;- data.frame(.coords, row.names=.chosen);&quot;, &quot;colnames(plot.data) &lt;- c(&#39;X&#39;, &#39;Y&#39;);&quot; ) } commands &lt;- c(commands, &quot;plot.data &lt;- plot.data[colnames(se),,drop=FALSE];&quot;, &quot;rownames(plot.data) &lt;- colnames(se);&quot;) eval(parse(text=commands), envir=envir) list(data_cmds=commands, plot_title=sprintf(&quot;Dynamic %s plot&quot;, x[[&quot;Type&quot;]]), x_lab=paste0(x[[&quot;Type&quot;]], &quot;1&quot;), y_lab=paste0(x[[&quot;Type&quot;]], &quot;2&quot;)) }) We use functions from the scater package to do the actual heavy lifting of calculating the dimensionality reduction results. The exists() call will check whether any column selection is being transmitted to this panel; if not, it will just return a plot.data variable that contains all NAs such that an empty plot is created. If col_selected does exist, it will contain a list of character vectors specifying the active and saved multiple selections that are being transmitted. For this particular example, we do not care about the distinction between active/saved selections so we just take the union of all of them. Of course, this is not quite the most efficient way to implement a plotting panel that involves recomputation. A better approach would be to cache the x/y coordinates and reuse them if only aesthetic parameters have changed, thus avoiding an unnecessary delay from recomputation. Doing so requires overriding .renderOutput() to take advantage of the cached contents of the plot, so we will omit that here for simplicity. 5.6 Finishing touches For this particular panel class, an additional helpful feature is to override .multiSelectionInvalidated. This indicates that any brushes or lassos in our plot should be destroyed when we receive a new column selection. Doing so is the only sensible course of action as the reduced dimension coordinates for one set of samples have no obvious relationship to the coordinates for another set of samples; having old brushes or lassos hanging around would be of no benefit at best, and be misleading at worst. setMethod(&quot;.multiSelectionInvalidated&quot;, &quot;DynRedDimPlot&quot;, function(x) TRUE) 5.7 In action Let’s put our new panel to the test. We use the sce object, preprocessed in a previous chapter, including some precomputed dimensionality reduction results. The plan is to create a (fixed) reduced dimension plot that will transmit a multiple selection to our dynamic reduced dimension plot. This is as easy as: rdp &lt;- RedDimPlot(PanelId=1L) drdp &lt;- new(&quot;DynRedDimPlot&quot;, SelectColSource=&quot;RedDimPlot1&quot;) app &lt;- iSEE(sce, initial=list(rdp, drdp)) Brushing at any location in RedDimPlot1 will then trigger dynamically recompution of results in our DynRedDimPlot. "],
["dynamic-differential-expression.html", "Chapter 6 Dynamic differential expression 6.1 Overview 6.2 Class basics 6.3 Setting up the interface 6.4 Creating the observers 6.5 Making the table 6.6 Finishing touches 6.7 In action", " Chapter 6 Dynamic differential expression 6.1 Overview In this case study, we will create a panel class to dynamically compute differential expression (DE) statistics between the active sample-level selection and the other saved selections from a transmitting panel. We will present the results of this computation in a DataTable widget from the DT package, where each row is a gene and each column is a relevant statistic (\\(p\\)-value, FDR, log-fold changes, etc.). 6.2 Class basics First, we define the basics of our new Panel class. As our new class will be showing each gene as a row, we inherit from the RowTable virtual class. This automatically gives us access to all the functionality promised in the contract, including interface elements and observers to respond to multiple selections. We also add a slot specifying the log-fold change threshold to use in the null hypothesis. Any new slots should come with validity methods, as shown below. library(S4Vectors) setValidity2(&quot;DGETable&quot;, function(object) { msg &lt;- character(0) if (length(val &lt;- object[[&quot;LogFC&quot;]])!=1L || val &lt; 0) { msg &lt;- c(msg, &quot;&#39;NGenes&#39; must be a non-negative number&quot;) } if (length(msg)) { return(msg) } TRUE }) It is also worthwhile specializing the initialize() method to provide a default for new parameters. We hard-code the SelectColType setting as we want to obtain all multiple selections from the transmitting panel, in order to be able to perform pairwise DE analyses between the various active and saved selections. (By comparison, the default of \"Active\" will only transmit the current active selection.) setMethod(&quot;initialize&quot;, &quot;DGETable&quot;, function(.Object, LogFC=0, ...) { callNextMethod(.Object, LogFC=LogFC, SelectColType=&quot;Union&quot;, ...) }) 6.3 Setting up the interface The most basic requirement is to define some methods that describe our new panel in the iSEE() interface. This includes defining the full name and desired default color for display purposes: setMethod(&quot;.fullName&quot;, &quot;DGETable&quot;, function(x) &quot;Differential expression table&quot;) setMethod(&quot;.panelColor&quot;, &quot;DGETable&quot;, function(x) &quot;#55AA00&quot;) We also add interface elements to change the result type and the number of genes. This is most easily done by specializing the .defineDataInterface method: library(shiny) setMethod(&quot;.defineDataInterface&quot;, &quot;DGETable&quot;, function(x, se, select_info) { plot_name &lt;- .getEncodedName(x) list( numericInput(paste0(plot_name, &quot;_LogFC&quot;), label=&quot;Log-FC threshold&quot;, min=0, value=x[[&quot;LogFC&quot;]]) ) }) As we discussed before, we paste0 the name of our panel to the name of any parameter to ensure that the ID is unique to this instance of our panel. 6.4 Creating the observers We specialize .createObservers to define some observers to respond to changes in our new interface elements. Note the use of callNextMethod() to ensure that observers of the parent class are also created; this automatically ensures that we can respond to changes in parameters provided by RowTable. setMethod(&quot;.createObservers&quot;, &quot;DGETable&quot;, function(x, se, input, session, pObjects, rObjects) { callNextMethod() plot_name &lt;- .getEncodedName(x) .createUnprotectedParameterObservers(plot_name, fields=&quot;LogFC&quot;, input=input, pObjects=pObjects, rObjects=rObjects) }) The distinction between protected and unprotected parameters is less important for Tables; as long as the types of the columns do not change between renderings, any column or global selections (i.e., search terms) are usually still sensible. 6.5 Making the table When working with a RowTable subclass, the easiest way to change plotting content to override the .generateTable method. This is expected to generate a data.frame in the evaluation environment, returning the commands required to do so. In this case, we want to perform one-sided \\(t\\)-tests between the active selection and any number of saved selections. We will use the findMarkers() function from scran to compute the desired statistics. This performs all pairwise comparisons, so is not as efficient as could be, but it will suffice for this demonstration. setMethod(&quot;.generateTable&quot;, &quot;DGETable&quot;, function(x, envir) { empty &lt;- &quot;tab &lt;- data.frame(Top=integer(0), p.value=numeric(0), FDR=numeric(0));&quot; if (!exists(&quot;col_selected&quot;, envir, inherits=FALSE) || length(envir$col_selected)&lt;2L || !&quot;active&quot; %in% names(envir$col_selected)) { commands &lt;- empty } else { commands &lt;- c(&quot;.chosen &lt;- unlist(col_selected);&quot;, &quot;.grouping &lt;- rep(names(col_selected), lengths(col_selected));&quot;, sprintf(&quot;.de.stats &lt;- scran::findMarkers(logcounts(se)[,.chosen], .grouping, direction=&#39;up&#39;, lfc=%s)&quot;, x[[&quot;LogFC&quot;]]), &quot;tab &lt;- as.data.frame(.de.stats[[&#39;active&#39;]]);&quot; ) } eval(parse(text=commands), envir=envir) list(commands=commands, contents=envir$tab) }) Readers may notice that we prefix internal variables with . in our commands. This ensures that they do not clash with global variables created by iSEE() itself (which is not an issue when running the app, but makes things difficult when the code is reported for tracking purposes). 6.6 Finishing touches By default, all RowTables hide their multiple column selection parameter choices. This considers the typical use case where RowTables respond to a selection of rows, rather than a selection of columns as in our DGETable. Thus, we need to flip this around so that the unresponsive row selection parameters are hidden in the interface while the useful column selection parameters are visible. We do so by specializing the .hideInterface() method, which returns TRUE to indicate that a particular interface element should be hidden. We do not “un-hide” SelectColType and SelectColSaved here; our tests are always performed between the active versus saved selection, so there is no effect from choosing the selection type. setMethod(&quot;.hideInterface&quot;, &quot;DGETable&quot;, function(x, field) { if (field %in% c(&quot;SelectRowSource&quot;, &quot;SelectRowType&quot;, &quot;SelectRowSaved&quot;)) { TRUE } else if (field %in% &quot;SelectColSource&quot;) { FALSE } else { callNextMethod() } }) A more advanced version of this panel class might consider responding to a row selection by only performing the DE analysis on the selected features. In such cases, we would not need to hide SelectRowSource, though we will leave that as an exercise for the curious. 6.7 In action Let’s put our new panel to the test. We use the sce object, preprocessed in a previous chapter, including some precomputed dimensionality reduction results. The plan is to create a (fixed) reduced dimension plot that will transmit to our DGE table. Setting up the iSEE instance is as easy as: rdp &lt;- RedDimPlot(PanelId=1L, SelectBoxOpen=TRUE) dget &lt;- new(&quot;DGETable&quot;, SelectColSource=&quot;RedDimPlot1&quot;, PanelWidth=8L) app &lt;- iSEE(sce, initial=list(rdp, dget)) Brushing (or lassoing) at any location and saving the selection will trigger dynamic recompution of results in our DGETable. We can repeat this with any number of saved selections. "],
["annotated-gene-list.html", "Chapter 7 Annotated gene list 7.1 Overview 7.2 Class basics 7.3 Setting up the interface 7.4 Creating the observers 7.5 In action", " Chapter 7 Annotated gene list 7.1 Overview When given a gene list, we often need to look up the function of the top genes in a search engine. This typically involves copy-pasting the gene name or ID into the search box and pressing Enter, which is a pain. Instead, we can automate this process in iSEE by creating an annotated gene table. We demonstrate by showing how we can dynamically look up annotation for each gene in the rowData of a SummarizedExperiment. 7.2 Class basics First, we define the basics of our new Panel class. Our new class will be showing the gene-level metadata, so we inherit from the RowStatTable class that does exactly this. We add some slots specifying which column of the table contains our gene IDs, the type of ID and the organism database to use. We specialize the validity method to check that the IDColumn is either a string or NULL; if the latter, we assume that the ID is stored in the row name. We also add some cursory checks for the other parameters. allowable &lt;- c(&quot;ENSEMBL&quot;, &quot;SYMBOL&quot;, &quot;ENTREZID&quot;) setValidity2(&quot;GeneAnnoTable&quot;, function(object) { msg &lt;- character(0) if (!is.null(val &lt;- object[[&quot;IDColumn&quot;]]) &amp;&amp; (length(val)!=1L || is.na(val))) { msg &lt;- c(msg, &quot;&#39;IDColumn must be NULL or a string&quot;) } if (!isSingleString(orgdb &lt;- object[[&quot;Organism&quot;]])) { msg &lt;- c(msg, sprintf(&quot;&#39;Organism&#39; should be a single string&quot;, orgdb)) } if (!isSingleString(type &lt;- object[[&quot;IDType&quot;]]) || !type %in% allowable) { msg &lt;- c(msg, &quot;&#39;IDType&#39; should be &#39;ENSEMBL&#39;, &#39;SYMBOL&#39; or &#39;ENTREZID&#39;&quot;) } if (length(open &lt;- object[[&quot;AnnoBoxOpen&quot;]])!=1L || is.na(open)) { msg &lt;- c(msg, &quot;&#39;AnnoBoxOpen&#39; should be a non-missing logical scalar&quot;) } if (length(msg)) { return(msg) } TRUE }) We then specialize the initialize method to set reasonable defaults for these parameters. setMethod(&quot;initialize&quot;, &quot;GeneAnnoTable&quot;, function(.Object, IDColumn=NULL, Organism=&quot;org.Mm.eg.db&quot;, IDType=&quot;SYMBOL&quot;, AnnoBoxOpen=FALSE, ...) { callNextMethod(.Object, IDColumn=IDColumn, IDType=IDType, Organism=Organism, AnnoBoxOpen=AnnoBoxOpen, ...) }) 7.3 Setting up the interface We define the full name and desired default color for display purposes: setMethod(&quot;.fullName&quot;, &quot;GeneAnnoTable&quot;, function(x) &quot;Annotated gene table&quot;) setMethod(&quot;.panelColor&quot;, &quot;GeneAnnoTable&quot;, function(x) &quot;#AA1122&quot;) We want to add another UI element for showing the gene-level annotation. This is achieved by specializing the .defineOutput() method as shown below; note the prefixing by the panel name to ensure that output element IDs from different panels are unique. setMethod(&quot;.defineOutput&quot;, &quot;GeneAnnoTable&quot;, function(x, ...) { panel_name &lt;- .getEncodedName(x) tagList( callNextMethod(), # Re-using RowStatTable&#39;s definition. uiOutput(paste0(panel_name, &quot;_annotation&quot;)), hr() ) }) We also set up interface elements for changing the annotation parameters. We will put these elements in a separate “Annotation parameters” collapsible box, which is initialized in an opened or closed state depending on the AnnoBoxOpen slot. setMethod(&quot;.defineInterface&quot;, &quot;GeneAnnoTable&quot;, function(x, se, select_info) { panel_name &lt;- .getEncodedName(x) c( list( collapseBox( paste0(panel_name, &quot;_AnnoBoxOpen&quot;), title=&quot;Annotation parameters&quot;, open=x[[&quot;AnnoBoxOpen&quot;]], selectInput(paste0(panel_name, &quot;_IDColumn&quot;), label=&quot;ID-containing column:&quot;, choices=colnames(rowData(se)), selected=x[[&quot;IDColumn&quot;]] ), selectInput(paste0(panel_name, &quot;_IDType&quot;), label=&quot;ID type:&quot;, choices=allowable, selected=x[[&quot;IDType&quot;]] ), selectInput(paste0(panel_name, &quot;_Organism&quot;), label=&quot;Organism&quot;, choices=c(&quot;org.Hs.eg.db&quot;, &quot;org.Mm.eg.db&quot;), selected=x[[&quot;Organism&quot;]] ) ) ), callNextMethod() ) }) 7.4 Creating the observers We specialize .createObservers to define some observers to respond to changes in our new interface elements. Note the use of callNextMethod() to ensure that observers of the parent class are also created. setMethod(&quot;.createObservers&quot;, &quot;GeneAnnoTable&quot;, function(x, se, input, session, pObjects, rObjects) { callNextMethod() plot_name &lt;- .getEncodedName(x) .createUnprotectedParameterObservers(plot_name, fields=c(&quot;IDColumn&quot;, &quot;Organism&quot;, &quot;IDType&quot;), input=input, pObjects=pObjects, rObjects=rObjects) }) We need to set up a rendering expression for the annotation element that responds to the selected gene. By using .trackSingleSelection(), we ensure that this UI element updates in response to changes in the table selection. We add a series of protective measures to avoid the application crashing due to missing organism packages or unmatched IDs. setMethod(&quot;.renderOutput&quot;, &quot;GeneAnnoTable&quot;, function(x, se, ..., output, pObjects, rObjects) { callNextMethod() # Re-using RowStatTable&#39;s output rendering. panel_name &lt;- .getEncodedName(x) output[[paste0(panel_name, &quot;_annotation&quot;)]] &lt;- renderUI({ .trackSingleSelection(panel_name, rObjects) instance &lt;- pObjects$memory[[panel_name]] rowdata_col &lt;- instance[[&quot;IDColumn&quot;]] selectedGene &lt;- instance[[&quot;Selected&quot;]] if (!is.null(rowdata_col)) { selectedGene &lt;- rowData(se)[selectedGene,rowdata_col] } keytype &lt;- instance[[&quot;IDType&quot;]] selgene_entrez &lt;- NA if (keytype!=&quot;ENTREZID&quot;) { ORG &lt;- instance[[&quot;Organism&quot;]] if (require(ORG, character.only=TRUE, quietly=TRUE)) { orgdb &lt;- get(ORG) selgene_entrez &lt;- try(mapIds(orgdb, selectedGene, &quot;ENTREZID&quot;, keytype), silent=TRUE) } } else { selgene_entrez &lt;- selectedGene } if (is.na(selgene_entrez) || is(selgene_entrez, &quot;try-error&quot;)) { return(NULL) } fullinfo &lt;- rentrez::entrez_summary(&quot;gene&quot;, selgene_entrez) link_pubmed &lt;- paste0(&#39;&lt;a href=&quot;http://www.ncbi.nlm.nih.gov/gene/?term=&#39;, selgene_entrez, &#39;&quot; target=&quot;_blank&quot;&gt;Click here to see more at the NCBI database&lt;/a&gt;&#39;) mycontent &lt;- paste0(&quot;&lt;b&gt;&quot;,fullinfo$name, &quot;&lt;/b&gt;&lt;br/&gt;&lt;br/&gt;&quot;, fullinfo$description,&quot;&lt;br/&gt;&lt;br/&gt;&quot;, ifelse(fullinfo$summary == &quot;&quot;,&quot;&quot;,paste0(fullinfo$summary, &quot;&lt;br/&gt;&lt;br/&gt;&quot;)), link_pubmed) HTML(mycontent) }) }) Observant readers will note that the body of the rendering expression uses instance rather than x. This is intentional as it ensures that we are using the parameter settings from the current state of the app. If we used x, we would always be using the parameters from the initial state of the app, which is not what we want. 7.5 In action Let’s put our new panel to the test using the sce object, preprocessed in a previous chapter. Setting up the iSEE instance is as easy as: gat &lt;- new(&quot;GeneAnnoTable&quot;, PanelWidth=8L) app &lt;- iSEE(sce, initial=list(gat)) Clicking on any row will bring up the Entrez annotation (if available) for that feature. It is probably best to click on some well-annotated genes as the set of RIKEN transcripts at the front don’t have much annotation. "],
["gene-ontology-table.html", "Chapter 8 Gene ontology table 8.1 Overview 8.2 Class basics 8.3 Setting up the interface 8.4 Generating the output 8.5 Creating the observers 8.6 Handling selections 8.7 In action", " Chapter 8 Gene ontology table 8.1 Overview Here, we will construct a table of GO terms where selection of a row in the table causes transmission of a multiple selection of gene names. The aim is to enable us to transmit multiple row selections to other panels based on their membership of a gene set. This is a fairly involved example of creating a Panel subclass as we cannot easily inherit from an existing subclass; rather, we need to provide all the methods ourselves. 8.2 Class basics First, we define the basics of our new GOTable class. This inherits from the virtual base Panel class as it cannot meet any of the contractual requirements of the subclasses, what with the DataTable selection event triggering a multiple selection rather than a single selection. We add some slots to specify the feature ID type and the organism of interest as well as for DataTable parameters. We also add some checks for these parameters. allowable &lt;- c(&quot;ENSEMBL&quot;, &quot;SYMBOL&quot;, &quot;ENTREZID&quot;) setValidity2(&quot;GOTable&quot;, function(object) { msg &lt;- character(0) if (!isSingleString(orgdb &lt;- object[[&quot;Organism&quot;]])) { msg &lt;- c(msg, sprintf(&quot;&#39;Organism&#39; should be a single string&quot;, orgdb)) } if (!isSingleString(type &lt;- object[[&quot;IDType&quot;]]) || !type %in% allowable) { msg &lt;- c(msg, &quot;&#39;IDType&#39; should be &#39;ENSEMBL&#39;, &#39;SYMBOL&#39; or &#39;ENTREZID&#39;&quot;) } if (!isSingleString(object[[&quot;Selected&quot;]])) { msg &lt;- c(msg, &quot;&#39;Selected&#39; should be a single string&quot;) } if (!isSingleString(object[[&quot;Search&quot;]])) { msg &lt;- c(msg, &quot;&#39;Search&#39; should be a single string&quot;) } if (length(msg)) { return(msg) } TRUE }) We then specialize the initialize method to set reasonable defaults. setMethod(&quot;initialize&quot;, &quot;GOTable&quot;, function(.Object, Organism=&quot;org.Mm.eg.db&quot;, IDType=&quot;SYMBOL&quot;, Selected=&quot;&quot;, Search=&quot;&quot;, SearchColumns=character(0), ...) { callNextMethod(.Object, IDType=IDType, Organism=Organism, Selected=Selected, Search=Search, SearchColumns=SearchColumns, ...) }) 8.3 Setting up the interface We define the full name and desired default color for display purposes: setMethod(&quot;.fullName&quot;, &quot;GOTable&quot;, function(x) &quot;Gene ontology table&quot;) setMethod(&quot;.panelColor&quot;, &quot;GOTable&quot;, function(x) &quot;#BB00FF&quot;) We add our UI element for showing the gene set table, which is simply a DataTable object from the DT package. Note that shiny also has a dataTableOutput function so care must be taken to disambiguate them. setMethod(&quot;.defineOutput&quot;, &quot;GOTable&quot;, function(x, ...) { panel_name &lt;- .getEncodedName(x) tagList(DT::dataTableOutput(panel_name)) }) We set up interface elements for changing the annotation parameters. setMethod(&quot;.defineDataInterface&quot;, &quot;GOTable&quot;, function(x, se, select_info) { panel_name &lt;- .getEncodedName(x) list( selectInput(paste0(panel_name, &quot;_IDType&quot;), label=&quot;ID type:&quot;, choices=allowable, selected=x[[&quot;IDType&quot;]] ), selectInput(paste0(panel_name, &quot;_Organism&quot;), label=&quot;Organism&quot;, choices=c(&quot;org.Hs.eg.db&quot;, &quot;org.Mm.eg.db&quot;), selected=x[[&quot;Organism&quot;]] ) ) }) Our implementation will be a pure transmitter, i.e., it will not respond to row or column selections from other panels. To avoid confusion, we can hide all selection parameter UI elements by specializing the .hideInterface() method: setMethod(&quot;.hideInterface&quot;, &quot;GOTable&quot;, function(x, field) { if (field %in% &quot;SelectBoxOpen&quot;) { TRUE } else { callNextMethod() } }) 8.4 Generating the output We actually generate the output by specializing the .generateOutput() function, using the GO.db package to create a table of GO terms and their definitions. We also store the number of available genes in the contents - this will be used later to compute the percentage of all genes in a given gene set. setMethod(&quot;.generateOutput&quot;, &quot;GOTable&quot;, function(x, se, ..., all_memory, all_contents) { envir &lt;- new.env() commands &lt;- c(&quot;require(GO.db);&quot;, &quot;tab &lt;- select(GO.db, keys=keys(GO.db), columns=&#39;TERM&#39;);&quot;, &quot;rownames(tab) &lt;- tab$GOID;&quot;, &quot;tab$GOID &lt;- NULL;&quot;) eval(parse(text=commands), envir=envir) list( commands=list(commands), contents=list(table=envir$tab, available=nrow(se)) ) }) We don’t actually depend on any parameters of x itself to generate this table. However, one could imagine a more complex case where the GOTable itself responds to a multiple row selection, e.g., by subsetting to the gene sets that contain genes in the selected row. 8.5 Creating the observers We specialize .createObservers to define some observers to respond to changes in our new interface elements. This also involves creating an observer to respond to a change in the selection of a DataTable row, calling .requestActiveSelectionUpdate() to trigger changes in panels that are receiving the multiple row selection. (We set up observers for the search fields as well, as a courtesy to restore them properly upon re-rendering.) Note the use of callNextMethod() to ensure that observers of the parent class are also created. setMethod(&quot;.createObservers&quot;, &quot;GOTable&quot;, function(x, se, input, session, pObjects, rObjects) { callNextMethod() panel_name &lt;- .getEncodedName(x) .createUnprotectedParameterObservers(panel_name, fields=c(&quot;Organism&quot;, &quot;IDType&quot;), input=input, pObjects=pObjects, rObjects=rObjects) # Observer for the DataTable row selection: select_field &lt;- paste0(panel_name, &quot;_rows_selected&quot;) multi_name &lt;- paste0(panel_name, &quot;_&quot;, iSEE:::.flagMultiSelect) observeEvent(input[[select_field]], { chosen &lt;- input[[select_field]] if (length(chosen)==0L) { chosen &lt;- &quot;&quot; } else { chosen &lt;- rownames(pObjects$contents[[panel_name]]$table)[chosen] } previous &lt;- pObjects$memory[[panel_name]][[&quot;Selected&quot;]] if (chosen==previous) { return(NULL) } pObjects$memory[[panel_name]][[&quot;Selected&quot;]] &lt;- chosen .requestActiveSelectionUpdate(panel_name, rObjects, update_output=FALSE) }, ignoreNULL=FALSE) # Observer for the search field: search_field &lt;- paste0(panel_name, &quot;_search&quot;) observeEvent(input[[search_field]], { search &lt;- input[[search_field]] if (identical(search, pObjects$memory[[panel_name]][[&quot;Search&quot;]])) { return(NULL) } pObjects$memory[[panel_name]][[&quot;Search&quot;]] &lt;- search }) # Observer for the column search fields: colsearch_field &lt;- paste0(panel_name, &quot;_search_columns&quot;) observeEvent(input[[colsearch_field]], { search &lt;- input[[colsearch_field]] if (identical(search, pObjects$memory[[panel_name]][[&quot;SearchColumns&quot;]])) { return(NULL) } pObjects$memory[[panel_name]][[&quot;SearchColumns&quot;]] &lt;- search }) }) We set up a rendering expression for the output table by specializing .renderOutput(). This uses the renderDataTable() function from the DT package (again, this has a similar-but-not-identical function in shiny, so be careful which one you import.) Some effort is involved in making sure that the output table responds to the memorized parameter values of our GOTable panel. setMethod(&quot;.renderOutput&quot;, &quot;GOTable&quot;, function(x, se, ..., output, pObjects, rObjects) { callNextMethod() panel_name &lt;- .getEncodedName(x) output[[panel_name]] &lt;- DT::renderDataTable({ .trackUpdate(panel_name, rObjects) param_choices &lt;- pObjects$memory[[panel_name]] t.out &lt;- .retrieveOutput(panel_name, se, pObjects, rObjects) full_tab &lt;- t.out$contents$table pObjects$varname[[panel_name]] &lt;- &quot;tab&quot; chosen &lt;- param_choices[[&quot;Selected&quot;]] search &lt;- param_choices[[&quot;Search&quot;]] search_col &lt;- param_choices[[&quot;SearchColumns&quot;]] search_col &lt;- lapply(search_col, FUN=function(x) { list(search=x) }) # If the existing row in memory doesn&#39;t exist in the current table, we # don&#39;t initialize it with any selection. idx &lt;- which(rownames(full_tab)==chosen)[1] if (!is.na(idx)) { selection &lt;- list(mode=&quot;single&quot;, selected=idx) } else { selection &lt;- &quot;single&quot; } DT::datatable( full_tab, filter=&quot;top&quot;, rownames=TRUE, options=list( search=list(search=search, smart=FALSE, regex=TRUE, caseInsensitive=FALSE), searchCols=c(list(NULL), search_col), # row names are the first column! scrollX=TRUE), selection=selection ) }) }) 8.6 Handling selections Now for the most important bit - configuring the GOTable to transmit a multiple row selection to other panels. This is achieved by specializing a series of .multiSelection*() methods. The first is the .multiSelectionDimension(), which controls the dimension being transmitted: setMethod(&quot;.multiSelectionDimension&quot;, &quot;GOTable&quot;, function(x) &quot;row&quot;) The next most important method is the .multiSelectionCommands(), which tells iSEE() how to create the multiple row selection from the selected DataTable row. It is expected to return a vector of commands that, when evaluated, creates a character vector of row names for transmission. This has an option (index) to differentiate between active and saved selections, though the latter case is not relevant to our GOTable so we will simply ignore it. We also need to protect against cases where the requested GO term is not found, upon which we simply return an empty character vector. setMethod(&quot;.multiSelectionCommands&quot;, &quot;GOTable&quot;, function(x, index) { orgdb &lt;- x[[&quot;Organism&quot;]] type &lt;- x[[&quot;IDType&quot;]] c( sprintf(&quot;require(%s);&quot;, orgdb), sprintf(&quot;selected &lt;- tryCatch(select(%s, keys=%s, keytype=&#39;GO&#39;, column=%s)$SYMBOL, error=function(e) character(0));&quot;, orgdb, deparse(x[[&quot;Selected&quot;]]), deparse(type)), &quot;selected &lt;- intersect(selected, rownames(se));&quot; ) }) We also define some generics to indicate whether a DataTable row is currently selected, and how to delete that selection. For the latter, we replace the selected row with an empty string to indicate that no selection has been made, consistent with the actions of our observer in .createObservers(). setMethod(&quot;.multiSelectionActive&quot;, &quot;GOTable&quot;, function(x) { if (x[[&quot;Selected&quot;]]!=&quot;&quot;) { x[[&quot;Selected&quot;]] } else { NULL } }) setMethod(&quot;.multiSelectionClear&quot;, &quot;GOTable&quot;, function(x) { x[[&quot;Selected&quot;]] &lt;- &quot;&quot; x }) Finally, we define a method to determine the total number of available genes. The default is to use the number of rows of the data.frame used in the datatable() call, but that would not be right for us as it represents the number of gene sets. Instead, we use the availability information that we previously stored in the contents during .generateOutput(). setMethod(&quot;.multiSelectionAvailable&quot;, &quot;GOTable&quot;, function(x, contents) { contents$available }) 8.7 In action Let’s put our new panel to the test using the sce object, preprocessed in a previous chapter. Setting up the iSEE instance is as easy as: got &lt;- new(&quot;GOTable&quot;, PanelWidth=8L) rst &lt;- RowStatTable(SelectRowSource=&quot;GOTable1&quot;) app &lt;- iSEE(sce, initial=list(got, rst)) Clicking on any row in the GOTable will subset RowTable1 to only those genes in the corresponding GO term. "],
["references.html", "References", " References "]
]
