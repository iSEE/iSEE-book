# Developing new panels {#developing}

First things first, we need to load the `r Biocpkg("iSEE")` package for this chapter.

```{r, message=FALSE}
library(iSEE)
```

# The panel API

Fully functional panel class must implement - or inherit from their parent class - the full set of methods that composes the API allowing panels to interact and communicate with the reactive infrastructure of `r Biocpkg("iSEE")` applications.

- a validity method, defined using `setValidity2`.
- `.fullName`, used to generate a unique full name uniquely identifying each panel instance in the GUI.
- `.cacheCommonInfo`, computing and caching static information about a `SummarizedExperiment` object regularly used by other API methods.
- `initialize`, creating a new panel instance with panel settings initialized with empty default values
- `.refineParameters`, replacing invalid panel settings with appropriate values.
- `.defineInterface`, used to define panel-specific Shiny widgets receiving user inputs in the GUI.
- `.createObservers`, used to define reactive functions that update internal reactive objects following user interactions.
- `.getCommandsDataXY`, used to generate commands and labels related to the x-axis and y-axis of panel classes producing a plot output.

## Create a new S4 class

In the chapter [Panel classes](#panels), we saw how each type of panel is defined as an S4 class, organised in a hierarchy that allows new panel classes to inherit sets of the properties and functionality from parent classes.

Therefore, developing a new panel starts with the creation of a new class.
While it is possible to create a new panel class from scratch, this is an advanced use case described in a separate section. <!-- TODO: cross-reference when done. -->
Instead, new panels classes can be much more rapidly derived from a parent panel class, using the inheritance relationships between classes to reuse properties and functionality defined in the parent class.

The choice of a parent class for the new panel depends on the properties that we want that new panel to have.
For instance, let us say that we want to define a new panel that has all the functionality of the _Reduced dimension plot_ panel type, but summarizes data into a layer of hexagonal bins instead of showing each individual data point.

To start, we declare our new class with a new unique name, _e.g._ `RedDimHexbinPlot`, that contains the builtin panel class `RedDimPlot`.

```{r}
setClass("RedDimHexbinPlot", contains="RedDimPlot")
```

<!-- TODO:
override the .getEncodedName and .getFullName methods
potentially, at that point users could already launch a GUI to see the result
-->

<!-- TODO:
second fastest visual result:
override the plotting function
-->

<!-- TODO: add a UI (preferably that affects XY) -->

<!-- TODO: add an observer -->

<!-- TODO: override the XY data logic -->

<!-- TODO: override the plot logic (again, see above) -->
