# (PART) Worked examples {-}

```{r, include=FALSE}
knitr::opts_chunk$set(message = FALSE, warning = FALSE, error = FALSE, cache = FALSE)
suppressPackageStartupMessages(require(BiocStyle))
options(digits = 4)
```

# Developing new panels {#developing}

First, we need to load the `r Biocpkg("iSEE")` package for this chapter.
This action imports all the builtin panel class definitions, including the virtual class `Panel` that is the base class for any `r Biocpkg("iSEE")` panel class.

```{r}
library(iSEE)
```

We also set up an example using our favorite dataset, creating a `SingleCellExperiment` object with some precomputed dimensionality reduction results.

```{r}
library(scRNAseq)
sce <- ReprocessedAllenData(assays="tophat_counts")

library(scater)
sce <- logNormCounts(sce, exprs_values="tophat_counts")
sce <- runPCA(sce, ncomponents=4)
sce <- runTSNE(sce)
```

```{r, include=FALSE}
# Checkpoint for subsequent chapters
saveRDS(sce, "sce.rds")
```

## Create a new S4 class

In the chapter [Panel classes](#panels), we saw how each type of panel is defined as an S4 class, organised in a hierarchy that allows new panel classes to inherit sets of properties and functionality from parent classes.

As a result, developing a new panel type starts with the creation of a new class that inherits from the `Panel` class.

While it is possible to create a new panel class that directly inherits from the top-most virtual `Panel` class, this is the most advanced use case that we will describe in later chapters. <!-- TODO: cross-reference when done. -->

Instead, new concrete panel classes can be rapidly derived from other concrete parent panel classes, using the inheritance relationships between classes to reuse properties and functionality defined in the parent classes and its own parent classes.

The choice of a parent class depends on the properties that we want that new panel class to start with.
For instance, to create a panel that inherits all the functionality of the `ReducedDimensionPlot` panel type, we simply define a new class that extends that class.
For example in this chapter, we call that new class `RedDimHexPlot`.

```{r}
setClass("RedDimHexPlot", contains="ReducedDimensionPlot")
```

## Add a constructor function

At this point, it is already possible to create instances of the new panel class.
However, to facilitate this, new panels should provide a constructor function - best practice is to name it identically to the class - to accept arbitrary arguments controlling the initialization of new panel instances created by the function `new()`.

Here, we define a simple constructor function that passes all incoming arguments _as is_ to `new()`.

```{r}
RedDimHexPlot <- function(...) {
    new("RedDimHexPlot", ...)
}
```

At this point, we can already use instances of this new panel class in `r Biocpkg("iSEE")` apps.

```{r}
RedDimHexPlot1 <- RedDimHexPlot()
initial <- list(RedDimHexPlot1)
app <- iSEE(sce, initial = initial)
```

However, that would not be very exciting as instances of this new panel class would behave exactly like the those of the parent `ReducedDimensionPlot` class itself.
To illustrate this, the following code chunk initializes an app displaying an instance of the new `RedDimHexPlot` and its parent `ReducedDimensionPlot` side by side.

```{r}
RedDimHexPlot1 <- RedDimHexPlot()
ReducedDimensionPlot1 <- ReducedDimensionPlot()
initial <- list(RedDimHexPlot1, ReducedDimensionPlot1)
app <- iSEE(sce, initial = initial)
```

## Set the panel name in the GUI

The panel class that we created so far also inherited the name of the parent panel class.
In other words, instances of both classes are entirely indistinguishable from each other in the GUI.

The name of each panel displayed in the GUI is defined by the method `.fullName()`.
To clearly distinguish the new panel class in the GUI, we overwrite this method to display a name different from the parent class.

```{r}
setMethod(".fullName", "RedDimHexPlot", function(x) "Reduced dimension hexagonal plot")
```

With that, launching `app` again now highlights how panels of the new class now display a different title from the parent class.

## Define the commands generating a plot output

Importantly, the API separates the generation of commands processing data from `sce` into a data-frame, from the generation of commands producing a `ggplot` object using the processed data-frame.
If a new panel class derived from `DotPlot` is meant to process data in the same way as its parent panel, only to display it in a different way, it is then possible to overwrite only the method `.generateDotPlot()`.
Meanwhile, the data preprocessing will be implicitly handled by the other API methods inherited from the parent class.

Importantly, the method `.generateDotPlot()` requires two key arguments: `labels` provides the plot labels for each of the aesthetics in the plot data, and `envir` provides the environment in which the plotting commands are to be evaluated to produce the `ggplot` object.

In particular, the contract offered by iSEE to panel developers promises the presence of certain variables in `envir`, that `.generateDotPlot()` can rely on.
Using those environment variables, `.generateDotPlot()` can make decisions altering the plotting commands and the resulting `ggplot` object.
For instance, the most important environment variable is `plot.data`, the data-frame that contains one row per data point to display in `DotPlot` panels.

Readers should refer to the **"Generating the ggplot object"** section of `help(".generateDotPlot", "iSEE")` for more information.

As an example, we overwrite the method `.generateDotPlot()` for the new class `RedDimHexPlot` to simply show the number of data points in the plotting area as a heatmap dividing the plane into regular hexagons.
Notably, the contract described above guarantees that the function can immediately rely on the `plot.data` data-frame that is computed by methods defined for the parent class `ReducedDimensionPlot`.
We also use the precomputed aesthetic `labels` associated with each column of `plot.data`, while setting a fixed label `"Count"` for the `fill` aesthetic associated with the count of observation in each hexagonal bin.

```{r}
setMethod(".generateDotPlot", "RedDimHexPlot", function(x, labels, envir) {
    stopifnot(require(ggplot2))
    
    plot_cmds <- list()
    plot_cmds[["ggplot"]] <- "ggplot() +"
    
    # Adding hexbins to the plot.
    plot_cmds[["hex"]] <- "geom_hex(aes(X, Y), plot.data) +"
    plot_cmds[["labs"]] <- "labs(fill='Count') +"
    plot_cmds[["labs"]] <- sprintf(
        "labs(x='%s', y='%s', title='%s', fill='%s') +",
        labels$X, labels$Y, labels$title, "Count"
        )
    plot_cmds[["theme_base"]] <- "theme_bw() +"
    plot_cmds[["theme_legend"]] <- "theme(legend.position = 'bottom')"
    
    gg_plot <- eval(parse(text=plot_cmds), envir)
    
    list(plot=gg_plot, commands=plot_cmds)
})
```

Running `app` again highlights how the `RedDimHexPlot` panel fills each hexagonal bin with a color indicating the number of data points present in the corresponding area in the `ReducedDimensionPlot` panel.

<!-- TODO:
second fastest visual result:
override the plotting function
-->

<!-- TODO: add a UI (preferably that affects XY) -->

<!-- TODO: add an observer -->

<!-- TODO: override the XY data logic -->

<!-- TODO: override the plot logic (again, see above) -->
