% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
%
\documentclass[
]{book}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math}
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\hypersetup{
  pdftitle={Extending iSEE},
  pdfauthor={Kevin Rue-Albrecht, Federico Marini, Charlotte Soneson, and Aaron Lun},
  hidelinks,
  pdfcreator={LaTeX via pandoc}}
\urlstyle{same} % disable monospaced font for URLs
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\usepackage{framed}
\definecolor{shadecolor}{RGB}{248,248,248}
\newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{0.94,0.16,0.16}{#1}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.77,0.63,0.00}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{0.64,0.00,0.00}{\textbf{#1}}}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.81,0.36,0.00}{\textbf{#1}}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\usepackage{longtable,booktabs}
% Correct order of tables after \paragraph or \subparagraph
\usepackage{etoolbox}
\makeatletter
\patchcmd\longtable{\par}{\if@noskipsec\mbox{}\fi\par}{}{}
\makeatother
% Allow footnotes in longtable head/foot
\IfFileExists{footnotehyper.sty}{\usepackage{footnotehyper}}{\usepackage{footnote}}
\makesavenoteenv{longtable}
\usepackage{graphicx,grffile}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
% Set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{5}
\usepackage{booktabs}
\usepackage[]{natbib}
\bibliographystyle{apalike}

\title{Extending \emph{iSEE}}
\author{Kevin Rue-Albrecht, Federico Marini, Charlotte Soneson, and Aaron Lun}
\date{2020-11-03}

\begin{document}
\maketitle

{
\setcounter{tocdepth}{1}
\tableofcontents
}
\hypertarget{preface}{%
\chapter*{Preface}\label{preface}}
\addcontentsline{toc}{chapter}{Preface}

The \href{https://bioconductor.org/}{Bioconductor} package \emph{\href{https://bioconductor.org/packages/3.12/iSEE}{iSEE}} provides functions to create an interactive graphical user interface (GUI) using the \href{https://rstudio.com/}{RStudio} \emph{\href{https://CRAN.R-project.org/package=Shiny}{Shiny}} package for exploring data stored in \emph{\href{https://bioconductor.org/packages/3.12/SummarizedExperiment}{SummarizedExperiment}} objects \citep{rue2018isee}.
This book describes how to use \emph{\href{https://bioconductor.org/packages/3.12/iSEE}{iSEE}}'s application programming interface (API) to develop new panel types for custom visualizations.
We also present case studies to illustrate the development process for a variety of custom panels.

The contents of this book are intended for developers of custom panel classes, usually inside a dedicated package like \emph{\href{https://bioconductor.org/packages/3.12/iSEEu}{iSEEu}}.
Potential end-users of \emph{\href{https://bioconductor.org/packages/3.12/iSEE}{iSEE}} should refer to the vignettes provided on the package landing page.

\hypertarget{part-api-overview}{%
\part{API overview}\label{part-api-overview}}

\hypertarget{panels}{%
\chapter{Panel classes}\label{panels}}

\hypertarget{overview}{%
\section{Overview}\label{overview}}

This chapter provides a list of all of the classes that are implemented by the core \emph{\href{https://bioconductor.org/packages/3.12/iSEE}{iSEE}} package.
Each class comes with its specialized implementations of methods for various generics described in Chapter \ref{api}.
Thus, it is often possible for developers to inherit from one of these classes to get most of the relevant methods implemented ``for free''.
The classes themselves are either virtual or concrete; the latter can be created and used directly in an \texttt{iSEE()} application,
while the former can only be used as a parent of a concrete subclass.
Here, we will provide a brief summary of each class along with a listing of its available slots.
Readers should refer to the documentation for each class (links below) for more details.

\hypertarget{virtual-classes}{%
\section{Virtual classes}\label{virtual-classes}}

The \href{https://isee.github.io/iSEE/reference/Panel-class.html}{\texttt{Panel}} class is the base class for all \emph{\href{https://bioconductor.org/packages/3.12/iSEE}{iSEE}} panels.
It provides functionality to control general panel parameters such as the panel width and height.
It also controls the transmission of multiple row/column selections across panels.

The \href{https://isee.github.io/iSEE/reference/DotPlot-class.html}{\texttt{DotPlot}} class inherits from the \texttt{Panel} class and is the base class for dot-based plots.
This refers to all plots where each row or column is represented by no more than one dot (i.e., point) on the plot.
It provides functionality to create the plot, control the aesthetics of the points and to manage the brush/lasso selection.

The \href{https://isee.github.io/iSEE/reference/ColumnDotPlot-class.html}{\texttt{ColumnDotPlot}} class inherits from the \texttt{DotPlot} class and represents all per-column dot plots.
This refers to all plots where each column is represented by no more than one dot on the plot.
It provides functionality to modify the plot aesthetics based on per-column values in the \texttt{colData} or assays.
It is also restricted to receiving and transmitting column identities in single and multiple selections.

The \href{https://isee.github.io/iSEE/reference/RowDotPlot-class.html}{\texttt{RowDotPlot}} class inherits from the \texttt{DotPlot} class and represents all per-row dot plots.
This refers to all plots where each row is represented by no more than one dot on the plot.
It provides functionality to modify the plot aesthetics based on per-row values in the \texttt{rowData} or assays.
It is also restricted to receiving and transmitting row identities in single and multiple selections.

The \href{https://isee.github.io/iSEE/reference/Table-class.html}{\texttt{Table}} class inherits from the \texttt{Panel} class and represents all tables rendered using \emph{\href{https://CRAN.R-project.org/package=DT}{DT}}.
Each row of the table is expected to correspond to a row or column of the \texttt{SummarizedExperiment}.
This class provides functionality to render the \texttt{DT::datatable} widget, monitor single/multiple selections and apply search filters.

The \href{https://isee.github.io/iSEE/reference/ColumnTable-class.html}{\texttt{ColumnTable}} class inherits from the \texttt{Table} class and represents all tables where the rows have a one-to-zero-or-one mapping to columns of the \texttt{SummarizedExperiment}.
Instances of this class can only transmit single and multiple selections on columns.

The \href{https://isee.github.io/iSEE/reference/RowTable-class.html}{\texttt{RowTable}} class inherits from the \texttt{Table} class and represents all tables where the rows have a one-to-zero-or-one mapping to rows of the \texttt{SummarizedExperiment}.
Instances of this class can only transmit single and multiple selections on rows.

\hypertarget{concrete-classes}{%
\section{Concrete classes}\label{concrete-classes}}

The \href{https://isee.github.io/iSEE/reference/ReducedDimensionPlot-class.html}{\texttt{ReducedDimensionPlot}} class inherits from the \texttt{ColumnDotPlot} class and plots reduced dimension coordinates from an entry of the \texttt{reducedDims} in a \texttt{SingleCellExperiment}.
It provides functionality to choose the result and extract the relevant dimensions in preparation for plotting.

The \href{https://isee.github.io/iSEE/reference/FeatureAssayPlot-class.html}{\texttt{FeatureAssayPlot}} class inherits from the \texttt{ColumnDotPlot} class and plots the assay values for a feature across all samples, using an entry of the \texttt{assays()} from any \texttt{SummarizedExperiment} object.
It provides functionality to choose the feature of interest and any associated variable to plot on the x-axis, where the feature of interest can be chosen by a single selection from other row-transmitting panels.

The \href{https://isee.github.io/iSEE/reference/ColumnDataPlot-class.html}{\texttt{ColumnDataPlot}} class inherits from the \texttt{ColumnDotPlot} class and plots \texttt{colData} variables by themselves or against each other.
It provides functionality to choose the variables to plot.

The \href{https://isee.github.io/iSEE/reference/SampleAssayPlot-class.html}{\texttt{SampleAssayPlot}} class inherits from the \texttt{RowDotPlot} class and plots the assay values for a sample across all features, using an entry of the \texttt{assays()} from any \texttt{SummarizedExperiment} object.
It provides functionality to choose the sample of interest and any associated variable to plot on the x-axis, where the sample of interest can be chosen by a single selection from other column-transmitting panels.

The \href{https://isee.github.io/iSEE/reference/RowDataPlot-class.html}{\texttt{RowDataPlot}} class inherits from the \texttt{RowDotPlot} class and plots \texttt{rowData} variables by themselves or against each other.
It provides functionality to choose and extract the variables to plot.

The \href{https://isee.github.io/iSEE/reference/ColumnDataTable-class.html}{\texttt{ColumnDataTable}} class inherits from the \texttt{ColumnTable} class and shows the contents of the \texttt{colData} in a table.
It provides functionality to extract the \texttt{colData} in preparation for rendering.

The \href{https://isee.github.io/iSEE/reference/RowDataTable-class.html}{\texttt{RowDataTable}} class inherits from the \texttt{RowTable} class and shows the contents of the \texttt{rowData} in a table.
It provides functionality to extract the \texttt{rowData} in preparation for rendering.

The \href{https://isee.github.io/iSEE/reference/ComplexHeatmapPlot-class.html}{\texttt{ComplexHeatmapPlot}} class inherits from the \texttt{Panel} class and creates a heatmap from assay values using the \emph{\href{https://bioconductor.org/packages/3.12/ComplexHeatmap}{ComplexHeatmap}} package.
It provides functionality to specify the features to be shown, which assay to show, transformations to be applied, and which metadata variables to display as row and column heatmap annotations.

Further examples of concrete classes are also available in the \emph{\href{https://bioconductor.org/packages/3.12/iSEEu}{iSEEu}} package.

\hypertarget{extending-the-classes}{%
\section{Extending the classes}\label{extending-the-classes}}

When creating a new panel class, it is necessary to inherit from a \texttt{Panel} subclass.
An appropriate choice of subclass can save a lot of work by providing that access to all of that subclass's generics.
This means that only a few methods need to be manually specialized to finish the panel, usually to change the output or interface.

\textbf{Case study 1.}
If we wanted to create a \texttt{Panel} with a different plot for viewing the dimensionality reduction results, we could inherit from the \texttt{ReducedDimensionPlot} panel.
This gives us access to the interface elements to choose the reduced dimensions, plus the underlying code to extract the values for plotting.
Then, we only need to overwrite the generic responsible for generating the plot.
Note that the \texttt{ReducedDimensionPlot} is itself a subclass of the \texttt{ColumnDataPlot}, so there is an implicit assumption that each column of the \texttt{SummarizedExperiment} will be represented as a single point on the plot.
(Conceptually, at least. The point can be invisible.)

\textbf{Case study 2.}
Let's say we want to create a \texttt{Panel} to plot the assay values of a feature against the corresponding set of values in another assay, e.g., to plot gene expression against genotype in experiments with both RNA-seq and whole genome sequencing.
None of the existing concrete panels support the use of information from two separate assays, so we would not be able to inherit from them.
However, the plot would follow the expectations of the \texttt{ColumnDotPlot}, in that each column of the \texttt{SummarizedExperiment} would be represented no more than once on the plot.
Thus, we can inherit from the \texttt{ColumnDotPlot}, giving us automatic access to methods for managing the visual options and multiple column selections.
Then, we only need to define our own methods - to create the user interface elements to choose the two assays, and to extract those values in preparation for plotting.

\textbf{Case study 3.}
We might want to create a new heatmap that averages values across columns before displaying them.
This is not an uncommon request if our dataset contains many experimental groups and we want to compress them into averages for visualization.
However, we cannot easily inherit from the \texttt{ComplexHeatmapPlot} as it does not mandate the definition of a grouping factor.
We also cannot inherit from \texttt{DotPlot}s or \texttt{Table}s as we are not showing anything of the sort.
Thus, we must inherit from the \texttt{Panel} class and manually define methods for most of the generics.
(Though this task is not as hard as it seems, due to many utilities exported by \emph{\href{https://bioconductor.org/packages/3.12/iSEE}{iSEE}} to facilitate observer and interface set-up.)

\textbf{Case study 4.}
Finally, we want to create a table that dynamically computes statistics for each feature, e.g., for differential expression based on a user-selected factor.
We can thus inherit from the \texttt{RowTable} where each feature is represented by one row of the table.
Then, we just have to define interface elements to allow users to specify the nature of the computed statistics,
and to define a new method to actually generate the table of interest with said statistics.

\hypertarget{api}{%
\chapter{Panel generics}\label{api}}

\hypertarget{overview}{%
\section{Overview}\label{overview}}

This chapter runs through all generics provided by \emph{\href{https://bioconductor.org/packages/3.12/iSEE}{iSEE}} to implement class-specific behaviors.
More exhaustive documentation about each generic can be obtained in the usual way, e.g., \texttt{?.defineInterface}.
Do not be intimidated; it is rarely necessary to define methods for all of the generics shown here.
If your class inherits from an existing \texttt{Panel} subclass, many of these methods will be implemented for free, and all you have to do is to override a handful of methods to achieve the desired customization.
To this end, examining the \href{https://github.com/iSEE/iSEEu}{R code} underlying the various panels in the downstream \emph{\href{https://bioconductor.org/packages/3.12/iSEEu}{iSEEu}} package can be highly instructive.

\hypertarget{class-basics}{%
\section{Class basics}\label{class-basics}}

Class names are expected to be formatted with camelCase, e.g., \texttt{ReducedDimensionPlot}.
Abbreviations are acceptable if they are well-understood, e.g., \texttt{MAPlot}, otherwise full words should be used to describe the class.

If your new class contains new slots beyond those provided by the parent, we suggest defining an \texttt{initialize()} method to specify the defaults for each new slot.
We ensures that any \texttt{new()} call to create your class will do something sensible, even if not all arguments are explicitly provided.
We prefer specializing \texttt{initialize()} rather than specifying \texttt{prototype=} as the former provides more flexibility, especially when there are dependencies between parameters.
Note that this usually requires a \texttt{callNextMethod()} to ensure that initialization of parent slots is also performed.

We also suggest defining an appropriate validity method via \texttt{setValidity()} to ensure that all user-provided arguments for new slots are valid.
Note that the validity method will not have access to the \texttt{SummarizedExperiment} so you cannot, e.g., check whether a particular feature name exists in the dataset -
such checks are deferred to the \texttt{.refineParameters()} generic.
The validity method should only check the sensibility of a \texttt{Panel}'s slot values in isolation.

Finally, we define a lightweight constructor function with the same name as the class.
This should wrap \texttt{new()} to make it easy to construct a new instance of your class.

\hypertarget{parameter-set-up}{%
\section{Parameter set-up}\label{parameter-set-up}}

One of the very first tasks performed by \texttt{iSEE()} is to run through the list of provided \texttt{Panel}s to set up constants and parameters.
This is done before the Shiny session itself is fully launched to ensure that the app is initialized in a valid state.

\href{https://isee.github.io/iSEE/reference/setup-generics.html}{\texttt{.cacheCommonInfo()}} caches common values to be used for all instances of a particular panel class.
These cached values can be used to, e.g., populate the UI or set up constants to be used in the panel's output.
This avoids potentially costly re-calculations throughout the lifetime of the \texttt{iSEE()} application.
Note that the cached values are generated only once for a given class and will be applied globally to all instances of that class;
thus, this method should only be storing class-specific constants.

\href{https://isee.github.io/iSEE/reference/setup-generics.html}{\texttt{.refineParameters()}} edits the parameters of a panel to ensure that they are valid.
For example, we may need to restrict the choices of a selectize element to some pre-defined possibilities.
One can consider this generic to be the version of the validity method that has access to the \texttt{SummarizedExperiment},
and thus can be used to ``correct'' the slot values based on the known set of valid possibilities.
This generic is run for each panel during the \texttt{iSEE()} application set-up to validate the user-supplied panel configuration.

\hypertarget{defining-the-user-interface}{%
\section{Defining the user interface}\label{defining-the-user-interface}}

\hypertarget{in-general}{%
\subsection{In general}\label{in-general}}

The next task performed by \texttt{iSEE()} is to define the user interface (UI) for each panel.
Each panel follows the general structure of having all UI elements contained in a \texttt{box} element with a panel-specific header color.
It is mandatory that each input UI element is named according to the \texttt{PANEL\_SLOT} format,
where \texttt{PANEL} is the ``encoded name'' of the panel (see \texttt{?.getEncodedName}) and \texttt{SLOT} is the name of the slot that receives the input.

\href{https://isee.github.io/iSEE/reference/interface-generics.html}{\texttt{.defineInterface()}} defines the panel's UI for modifying parameters.
Widgest should be bundled into collapsible boxes (see \texttt{?collapseBox}) according to their approximate purpose.
By default, two boxes are created containing data-related and selection-related parameters, though more boxes can be added in subclasses.
This generic provides the most general mechanism for controlling the panel's UI.

\href{https://isee.github.io/iSEE/reference/interface-generics.html}{\texttt{.defineDataInterface()}} defines the UI for modifying all data-related parameters in a given panel.
Such parameters are fundamental to the interpretation of the panel's output, as opposed to their aesthetic counterparts.
This generic allows developers to fine-tune the data UI for subclasses without reimplementing the parent class's \texttt{.defineInterface()},
especially if we wish to re-use the parent's UI for visual-related parameters.
As each panel's data input is likely to require customization, this is the interface-related generic that has the greatest need for (non-trivial) specialization.

\href{https://isee.github.io/iSEE/reference/interface-generics.html}{\texttt{.defineSelectionEffectInterface()}} defines the UI for controlling the effects of a multiple row/column selection.
For example, in a \texttt{DotPlot}, this generic could provide UI elements to change the color of all selected points.
The idea here is to, again, provide a simpler alternative to specializing \texttt{.defineInterface} when only the selection effect needs to be changed in a subclass.

\href{https://isee.github.io/iSEE/reference/interface-generics.html}{\texttt{.hideInterface()}} determines whether certain UI elements should be hidden from the user.
This allows subclasses to hide easily inappropriate or irrelevant parts of the parent's UI, again without redefining \texttt{.defineInterface()} in its entirety.
For example, we can remove row selection UI elements for panels that only accept column selections.

\href{https://isee.github.io/iSEE/reference/getEncodedName.html}{\texttt{.fullName()}} returns the full name of a panel class.
This is typically a more English-readable version of the camelCase'd class name.

\href{https://isee.github.io/iSEE/reference/getPanelColor.html}{\texttt{.panelColor()}} is a very important generic that returns the color associated with the class.
This should be sufficiently dark that white text is visible on a background using this color.

\hypertarget{the-dotplot-visual-interface}{%
\subsection{\texorpdfstring{The \texttt{DotPlot} visual interface}{The DotPlot visual interface}}\label{the-dotplot-visual-interface}}

For \texttt{DotPlot} subclasses, the default interface automatically includes another collapsible box containing visual-related parameters.
We provide a number of additional API points to change the visual-related UI for a subclass without completely reimplementing \texttt{.defineInterface()}.
Of course, if we have already specialized \texttt{.defineInterface()}, then there's no need to define methods for these generics.
Similarly, these generics do not need to be specialized if the defaults are adequate.

\begin{itemize}
\tightlist
\item
  \href{https://isee.github.io/iSEE/reference/visual-parameters-generics.html}{\texttt{.defineVisualColorInterface()}} for color-related parameters.
\item
  \href{https://isee.github.io/iSEE/reference/visual-parameters-generics.html}{\texttt{.defineVisualFacetInterface()}} for facet-related parameters.
\item
  \href{https://isee.github.io/iSEE/reference/visual-parameters-generics.html}{\texttt{.defineVisualShapeInterface()}} for shape-related parameters.
\item
  \href{https://isee.github.io/iSEE/reference/visual-parameters-generics.html}{\texttt{.defineVisualSizeInterface()}} for size-related parameters.
\item
  \href{https://isee.github.io/iSEE/reference/visual-parameters-generics.html}{\texttt{.defineVisualPointInterface()}} for other point-related parameters.
\item
  \href{https://isee.github.io/iSEE/reference/visual-parameters-generics.html}{\texttt{.defineVisualTextInterface()}} for text-related parameters.
\item
  \href{https://isee.github.io/iSEE/reference/visual-parameters-generics.html}{\texttt{.defineVisualOtherInterface()}} for other parameters.
\end{itemize}

\hypertarget{creating-observers}{%
\section{Creating observers}\label{creating-observers}}

Once the interface is defined, \texttt{iSEE()} runs through all panels to set up its specific observers.
This is done once during app initialization and again whenever new panels are interactively added by the user.

\href{https://isee.github.io/iSEE/reference/observer-generics.html}{\texttt{.createObservers()}} sets up Shiny observers for the panel in the current session.
This is the workhorse function to ensure that the panel actually responds to user input.
Developers can define arbitrarily complex observer logic here as long as it is self-contained within a single panel -
interactive mechanics that involve communication between panels are handled elsewhere.
One should also remember to call \texttt{callNextMethod()} to ensure that the parent class's observers are also defined.

Note that, unlike typical \emph{\href{https://CRAN.R-project.org/package=shiny}{shiny}} applications, the \texttt{input} never directly interacts with the \texttt{output}.
All observers in an \emph{\href{https://bioconductor.org/packages/3.12/iSEE}{iSEE}} panel are expected to change the application's ``memory'' upon changes to the \texttt{input} - this concept is discussed more in Chapter \ref{server}.
Most developers can ignore this subtlety by using \emph{\href{https://bioconductor.org/packages/3.12/iSEE}{iSEE}}-provided utilities to set up the observers rather than calling \texttt{observeEvent()} directly.

\hypertarget{defining-panel-outputs}{%
\section{Defining panel outputs}\label{defining-panel-outputs}}

\hypertarget{in-general-1}{%
\subsection{In general}\label{in-general-1}}

Finally, \texttt{iSEE()} runs through each panel to define its output elements and rendering expressions.
When the app appears on the browser, each rendering expression will be triggered to generate the desired visual output.
Panels transmitting multiple selections will also have their output explicitly generated beforehand by \texttt{iSEE()} so that downstream panels can be initialized properly.

\href{https://isee.github.io/iSEE/reference/output-generics.html}{\texttt{.defineOutput()}} defines the interface element containing the output of the panel.
Examples include \texttt{plotOutput()} for plots or \texttt{dataTableOutput()} for tables.
Note that this generic only defines the output in the \texttt{iSEE()} interface; it does not control the rendering.

\href{https://isee.github.io/iSEE/reference/output-generics.html}{\texttt{.renderOutput()}} assigns a reactive expression to populate the output interface element with content.
This is usually as simple as calling functions like \texttt{renderPlotOutput()} with an appropriate rendering expression containing a call to \texttt{.retrieveOutput()}.

\href{https://isee.github.io/iSEE/reference/output-generics.html}{\texttt{.generateOutput()}} actually generates the panel output, be it a plot or table or something more exotic.
This is usually the real function that does all the work, being called by \texttt{.retrieveOutput()} prior to rendering the output.
Some effort is required here to ensure that the commands used to generate the output are also captured.

\href{https://isee.github.io/iSEE/reference/output-generics.html}{\texttt{.exportOutput()}} converts the panel output into a form that is downloadable, such as a PDF file for plots or CSVs for tables.
This is called whenever the user requests a download of the panel outputs.

\hypertarget{for-dotplots}{%
\subsection{\texorpdfstring{For \texttt{DotPlot}s}{For DotPlots}}\label{for-dotplots}}

For \texttt{DotPlot}s, additional generics are provided to customize specific aspects of the output.
These can be specialized to achieve the desired output without rewriting \texttt{.generateOutput()} in its entirety.
Of course, these are all optional and can be left as the defaults if those are satisfactory.

\href{https://isee.github.io/iSEE/reference/plot-generics.html}{\texttt{.generateDotPlot()}} creates the \texttt{ggplot} object for \texttt{DotPlot} subclasses, given a \texttt{data.frame} of data inputs.
Developers can specialize this generic if they only need to change the visualization while continuing to use the default data management.

\href{https://isee.github.io/iSEE/reference/plot-generics.html}{\texttt{.generateDotPlotData()}} creates the \texttt{data.frame} that is used by \texttt{.generateDotPlot()}.
This allows developers to change the data setup for a \texttt{DotPlot} subclass without having to specialize \texttt{.generateDotPlot()}, if they are satisfied with the default \texttt{DotPlot} aesthetics.

\href{https://isee.github.io/iSEE/reference/plot-generics.html}{\texttt{.prioritizeDotPlotData()}} determines how points should be prioritized during overplotting.
This usually doesn't need to be specialized but can be helpful if some points are more important than others (e.g., DE genes versus non-DE genes in a volcano plot).

\href{https://isee.github.io/iSEE/reference/plot-generics.html}{\texttt{.colorByNoneDotPlotField()}} and \href{https://isee.github.io/iSEE/reference/plot-generics.html}{\texttt{.colorByNoneDotPlotScale()}} define the default color scale when \texttt{ColorBy="None"}.
This usually doesn't need to be specialized but can be helpful, e.g., to change the color of DE genes according to the sign of the log-fold change.

\href{https://isee.github.io/iSEE/reference/metadata-plot-generics.html}{\texttt{.allowableYAxisChoices()}} and \href{https://isee.github.io/iSEE/reference/metadata-plot-generics.html}{\texttt{.allowableXAxisChoices()}} specifies the acceptable fields for the x- or y-axes of \texttt{ColumnDataPlot} or \texttt{RowDataPlot} subclasses.
This is typically used to constrain the choices for customized panels that only accept certain column names or types.
For example, a hypothetical MA plot panel would only accept log-fold changes on the y-axis.

\hypertarget{for-tables}{%
\subsection{\texorpdfstring{For \texttt{Table}s}{For Tables}}\label{for-tables}}

For \texttt{Table}s, the most important aspect is the generation of the underlying \texttt{data.frame}.
This can be customized without requiring the developer to rewrite the \emph{\href{https://CRAN.R-project.org/package=DT}{DT}}-related rendering of the table.

\href{https://isee.github.io/iSEE/reference/table-generics.html}{\texttt{.generateTable()}} creates the \texttt{data.frame} that is rendered into the table widget for \texttt{Table} subclasses.
Each row of the \texttt{data.frame} is generally expected to correspond to a row or column of the dataset.
If this is specialized, there is usually no need to specialize \texttt{.generateOutput()} for such subclasses.

\hypertarget{handling-selections}{%
\section{Handling selections}\label{handling-selections}}

\hypertarget{multiple}{%
\subsection{Multiple}\label{multiple}}

Some panels can transmit a selection of multiple row or columns (never both) to other panels.
\texttt{iSEE()} determines whether a particular panel is a multiple selection transmitter along the rows or columns (or neither) by interrogating a suite of generics.
Most new panels do not have to care about this if they inherit from \texttt{RowDotPlot}, \texttt{RowTable}, \texttt{ColumnDotPlot} or \texttt{ColumnTable};
however, more custom panels will have to specialize these generics manually if they intend to transmit multiple selections.

\href{https://isee.github.io/iSEE/reference/multi-select-generics.html}{\texttt{.multiSelectionDimension()}} specifies whether the panel transmits multiple selections along the rows or columns.
It can also be used to indicate that the panel does not transmit anything.

\href{https://isee.github.io/iSEE/reference/multi-select-generics.html}{\texttt{.multiSelectionActive()}} returns the parameters that define the ``active'' multiple selection in the current panel.
This is defined as the selection that the user can actively change by interacting with the panel.
(In contrast, the ``saved'' selections are fixed and can only be deleted.)

\href{https://isee.github.io/iSEE/reference/multi-select-generics.html}{\texttt{.multiSelectionCommands()}} creates the character vector of row or column names for a multiple selection in the current panel.
More specifically, it returns the commands that will then be evaluated to generate such character vectors.
The identity of the selected rows/columns will ultimately be transmitted to other panels to affect their behavior.

\href{https://isee.github.io/iSEE/reference/multi-select-generics.html}{\texttt{.multiSelectionAvailable()}} reports how many total points are available for selection in the current panel.
This is used for reporting ``percent selected'' statistics below each panel.

\href{https://isee.github.io/iSEE/reference/multi-select-generics.html}{\texttt{.multiSelectionClear()}} eliminates the active multiple selection in the current panel.
This is used to wipe selections in response to changes to the plot content that cause those selections to be invalid.

\href{https://isee.github.io/iSEE/reference/multi-select-generics.html}{\texttt{.multiSelectionRestricted()}} indicates whether the current panel's data should be restricted to the rows/columns that it receives from an incoming multiple selection.
This is used to determine how changes in the upstream transmitters should propagate through to the current panel's children.

\href{https://isee.github.io/iSEE/reference/multi-select-generics.html}{\texttt{.multiSelectionInvalidated()}} indicates whether the current panel is invalidated when it receives a new multiple selection.
This usually doesn't need to be specialized.

\hypertarget{single}{%
\subsection{Single}\label{single}}

Some panels can transmit a identity of a single feature or sample to other panels.
\texttt{iSEE()} determines whether a particular panel is a single selection transmitter along the features or samples (or neither) by interrogating a suite of generics.
Most new panels do not have to care about this if they inherit from \texttt{RowDotPlot}, \texttt{RowTable}, \texttt{ColumnDotPlot} or \texttt{ColumnTable};
however, more custom panels will have to specialize these generics manually if they intend to transmit single selections.

\href{https://isee.github.io/iSEE/reference/single-select-generics.html}{\texttt{.singleSelectionDimension()}} specifies whether the panel transmits single selections of a row or column.
It can also be used to indicate that the panel does not transmit anything.

\href{https://isee.github.io/iSEE/reference/single-select-generics.html}{\texttt{.singleSelectionValue()}} determines the row or column that has been selected in the current panel.
The identity of the row/column is passed onto other panels to affect their behavior.

\href{https://isee.github.io/iSEE/reference/single-select-generics.html}{\texttt{.singleSelectionSlots()}} determines how the current panel should respond to single selections from other panels.
This will also automatically set up some of the more difficult observers if sufficient information is supplied by the class.

\hypertarget{miscellaneous}{%
\section{Miscellaneous}\label{miscellaneous}}

\href{https://isee.github.io/iSEE/reference/documentation-generics.html}{\texttt{.definePanelTour()}} defines an \emph{\href{https://CRAN.R-project.org/package=rintrojs}{rintrojs}} tour for the functionalities of the current panel.
This guides users through a short tour of the current panel's most important features, reducing the need to consult external documentation.

\hypertarget{server}{%
\chapter{Application state}\label{server}}

\hypertarget{overview}{%
\section{Overview}\label{overview}}

\emph{\href{https://bioconductor.org/packages/3.12/iSEE}{iSEE}} uses global variables to keep track of the application state and to trigger reactive expressions.
These are passed in the ubiquitous \texttt{pObjects} and \texttt{rObjects} arguments for non-reactive and reactive variables, respectively.
Both of these objects have pass-by-reference semantics, meaning that any modifications to their contents within functions will persist outside of the function scope.
This enables their use in communicating changes across all components of the running \texttt{iSEE()} application.

For most part, developers of new panels do not need to be aware of these variables.
Only panels with relatively complex customizations need to manually specify the reactive logic or memory updates,
in which case they should use the various utilities provided by \emph{\href{https://bioconductor.org/packages/3.12/iSEE}{iSEE}} to mediate the interactions with \texttt{rObjects} and \texttt{pObjects}.
Developers should also refrain from adding their own application-wide variables.
Respecting this paradigm will ensure that custom panels behave correctly in the context of the entire application.

\hypertarget{updating-parameters}{%
\section{Updating parameters}\label{updating-parameters}}

The application memory is a list of \texttt{Panel} instances in \texttt{pObjects\$memory} that captures the current state of the \emph{\href{https://bioconductor.org/packages/3.12/iSEE}{iSEE}} application.
Conceptually, one should be able to extract this list from a running application, pass it to the \texttt{initial=} argument of the \texttt{iSEE()} function and expect to recover the same state.
All modifications to the state should be recorded in the memory, meaning that observer expressions will commonly contain code like:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pObjects}\OperatorTok{$}\NormalTok{memory[[panel_name]][[param_name]] <-}\StringTok{ }\NormalTok{new_value}
\end{Highlighting}
\end{Shaded}

By itself, modifying the application memory will not trigger any further actions.
The memory is too complex to be treated as a reactive value as it would affect too many downstream observers.
Instead, we provide the \texttt{.requestUpdate()} function to indicate to the application that a particular panel needs to be updated.
This sets a flag in \texttt{rObjects} that will eventually trigger re-rendering of the specified panel.

The \texttt{.requestCleanUpdate()} function provides a variant of this approach where the panel should be updated \emph{and} any active or saved multiple selections should be wiped.
This is useful for dealing with changes to ``protected'' parameters that modify the panel contents such that any selection parameters are no longer relevant (e.g., invalidating brushes when the plot coordinates change).
Yet another variant is the \texttt{.requestActiveSelectionUpdate()} function, which indicates whether a panel's active multiple selection has changed; this should be used in the observer expression that responds to the panel's multiple selection mechanism.

The two-step process of memory modification and calling \texttt{.requestUpdate()} is facilitated by functions like \texttt{.createUnprotectedParameterObservers()}, which sets up simple observers for parameter modifications.
However, more complex observers will have to do this manually.

\hypertarget{reading-the-memory}{%
\section{Reading the memory}\label{reading-the-memory}}

In a similar vein, expressions to render output should \emph{never} touch the Shiny \texttt{input} object directly.
(Indeed, \texttt{.renderOutput()} does not even have access to the \texttt{input}.)
As all parameter changes pass through the memory, the updated values of each parameter should also be retrieved from memory.
This involves extracting the desired \texttt{Panel} from \texttt{pObjects\$memory} in methods for generics like \texttt{.createObservers()} that rely on pass-by-reference semantics for correct evaluation of reactive expressions.
Other generics that are not setting up reactive expressions can directly extract values from the supplied \texttt{Panel} object.

Each \texttt{Panel} object can be treated as a list of panel parameters.
Retrieving values is as simple as using the \texttt{{[}{[}} operator with the name of the parameter.
(Similarly, setting parameters is as easy as using \texttt{{[}{[}\textless{}-}, though this should only be done in dedicated observers and never in rendering expressions.)
Direct slot access should be avoided, consistent with best practice for S4 programming.

\hypertarget{reacting-to-events}{%
\section{Reacting to events}\label{reacting-to-events}}

Developers can respond to events by calling functions like \texttt{.trackUpdate()} within an observer or rendering expression.
This touches \texttt{rObjects} to ensure that the enclosing expression is re-evaluated if the panel is updated elsewhere by \texttt{.requestUpdate()}.
Other variants like \texttt{.trackMultiSelection()} will trigger re-evaluation upon changes to the panel's multiple selections.

Direct use of \texttt{.trackUpdate()} and related functions is generally unnecessary as it is handled by higher-level functions like \texttt{.retrieveOutput()}.
Nonetheless, if some action needs to be taken after, e.g., a multiple selection, it may be appropriate to create an observer that calls \texttt{.trackMultiSelection()}.
Note that developers should only use these functions to track updates to the same panel for which the observer/rendering expression is written;
management of communication across panels is outside of the scope of these expressions.

\hypertarget{guidelines-for-user-globals}{%
\section{Guidelines for user globals}\label{guidelines-for-user-globals}}

Developers are free to define global parameters that affect all instances of their panel class.
This makes it easy for the user to modify the behavior of all instances of a particular panel.
However, we suggest that such user-visible globals limit their effects to the panel's constructor.
This enables users to reproduce the app state from one session to another by simply saving the memory;
otherwise, users would also have to export the state of the global variables.

This guideline implies that any global parameters should be represented as slots in the panel class.
Technically, this also means that different instances of a particular class might have different values for that same slot.
If all panels must have the same value, this can be enforced via some creative use of \texttt{.cacheCommonInfo} and \texttt{.refineParameters};
see, for example, the \texttt{MAPlot} class from the \emph{\href{https://bioconductor.org/packages/3.12/iSEEu}{iSEEu}} package.

\hypertarget{part-worked-examples}{%
\part{Worked examples}\label{part-worked-examples}}

\hypertarget{developing}{%
\chapter{Reduced dimension hexbin plot}\label{developing}}

\hypertarget{overview}{%
\section{Overview}\label{overview}}

In this example, we will create a panel class to show dimensionality reduction results using a hexbin plot.
The idea is to improve plotting speed for large datasets by binning points rather than showing each point individually.
Astute readers will note that the proposed class is the same as the \texttt{ReducedDimensionHexPlot} from \emph{\href{https://bioconductor.org/packages/3.12/iSEEu}{iSEEu}}.
This chapter will describe the most relevant aspects of the development process to create a reasonably functional class.

\hypertarget{class-basics}{%
\section{Class basics}\label{class-basics}}

The choice of a parent class depends on the properties that we want that new panel class to start with.
In this case, to create a panel that inherits all the functionality of the \texttt{ReducedDimensionPlot} panel type, we simply define a new class that extends that class.
We will call the new class \texttt{RedDimHexPlot}, adding an extra parameter to control the resolution of the hexbins.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setClass}\NormalTok{(}\StringTok{"RedDimHexPlot"}\NormalTok{, }\DataTypeTok{contains=}\StringTok{"ReducedDimensionPlot"}\NormalTok{, }
    \DataTypeTok{slots=}\KeywordTok{c}\NormalTok{(}\DataTypeTok{BinResolution=}\StringTok{"numeric"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

Any new slots should come with validity methods, as shown below.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(S4Vectors)}
\KeywordTok{setValidity2}\NormalTok{(}\StringTok{"RedDimHexPlot"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(object) \{}
\NormalTok{    msg <-}\StringTok{ }\KeywordTok{character}\NormalTok{(}\DecValTok{0}\NormalTok{)}

\NormalTok{    msg <-}\StringTok{ }\KeywordTok{.validNumberError}\NormalTok{(msg, object, }\StringTok{"BinResolution"}\NormalTok{, }\DataTypeTok{lower=}\DecValTok{1}\NormalTok{, }\DataTypeTok{upper=}\OtherTok{Inf}\NormalTok{) }\CommentTok{# i.e., >= 1.}

    \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{length}\NormalTok{(msg)) \{}
        \KeywordTok{return}\NormalTok{(msg)}
\NormalTok{    \}}
    \OtherTok{TRUE}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

We specialize the \texttt{initialize()} method to provide a default for the new parameter.
We also define a constructor function to make it easier to create a new instance.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setMethod}\NormalTok{(}\StringTok{"initialize"}\NormalTok{, }\StringTok{"RedDimHexPlot"}\NormalTok{,}
    \ControlFlowTok{function}\NormalTok{(.Object, }\DataTypeTok{BinResolution=}\DecValTok{20}\NormalTok{, ...)}
\NormalTok{\{}
    \KeywordTok{callNextMethod}\NormalTok{(.Object, }\DataTypeTok{BinResolution=}\NormalTok{BinResolution, ...)}
\NormalTok{\})}

\NormalTok{RedDimHexPlot <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(...) \{}
    \KeywordTok{new}\NormalTok{(}\StringTok{"RedDimHexPlot"}\NormalTok{, ...)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

At this point, we can already create and use instances of this new panel class in \emph{\href{https://bioconductor.org/packages/3.12/iSEE}{iSEE}} apps.
However, that would not be very exciting as instances of this new panel class would behave exactly like the those of the parent \texttt{ReducedDimensionPlot} class.
Let's define a few more methods to introduce some more relevant differences in behavior.

\hypertarget{setting-up-the-interface}{%
\section{Setting up the interface}\label{setting-up-the-interface}}

Currently, instances of our new class are indistinguishable from the parent \texttt{ReducedDimensionPlot} in the \texttt{iSEE} interface.
To differentiate our new class, we create a method for the \texttt{.fullName()} generic to show a different name.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setMethod}\NormalTok{(}\StringTok{".fullName"}\NormalTok{, }\StringTok{"RedDimHexPlot"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x) }\StringTok{"Reduced dimension hexagonal plot"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

While we're here, we might as well give the panel a different color as well.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setMethod}\NormalTok{(}\StringTok{".panelColor"}\NormalTok{, }\StringTok{"RedDimHexPlot"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x) }\StringTok{"#AA5500"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

We also override aspects of the user interface to add a parameter to modify the bin resolution.
Here, we place a \texttt{numericInput} widget into the set of parameters controlling the size aesthetics.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setMethod}\NormalTok{(}\StringTok{".defineVisualSizeInterface"}\NormalTok{, }\StringTok{"RedDimHexPlot"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x) \{}
\NormalTok{    plot_name <-}\StringTok{ }\KeywordTok{.getEncodedName}\NormalTok{(x)}
    \KeywordTok{tagList}\NormalTok{(}
        \KeywordTok{numericInput}\NormalTok{(}
            \KeywordTok{paste0}\NormalTok{(plot_name, }\StringTok{"_"}\NormalTok{, }\StringTok{"BinResolution"}\NormalTok{), }\DataTypeTok{label=}\StringTok{"Bin resolution:"}\NormalTok{,}
            \DataTypeTok{min=}\DecValTok{1}\NormalTok{, }\DataTypeTok{value=}\NormalTok{x[[}\StringTok{"BinResolution"}\NormalTok{]], }\DataTypeTok{step =} \DecValTok{1}\NormalTok{)}
\NormalTok{    )}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

Conversely, some other aspects of the UI are now irrelevant because we are no longer showing individual points.
This includes the shape of the points, point-related downsampling and a variety of other aesthetic features.
Thus, we hide or disable them to avoid cluttering the interface.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setMethod}\NormalTok{(}\StringTok{".hideInterface"}\NormalTok{, }\StringTok{"RedDimHexPlot"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x, field) \{}
    \ControlFlowTok{if}\NormalTok{ (field }\OperatorTok{==}\StringTok{ "Downsample"}\NormalTok{) }\OtherTok{TRUE} \ControlFlowTok{else} \KeywordTok{callNextMethod}\NormalTok{()}
\NormalTok{\})}

\KeywordTok{setMethod}\NormalTok{(}\StringTok{".defineVisualShapeInterface"}\NormalTok{, }\StringTok{"RedDimHexPlot"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x) \{}
    \OtherTok{NULL}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

\hypertarget{creating-the-observers}{%
\section{Creating the observers}\label{creating-the-observers}}

The only new UI element we added was the widget to control the bin resolution.
Thus, the only new observer that needs to be added is the one that responds to this element.
Note the use of \texttt{callNextMethod()} to ensure that the observers for the parent class are also instantiated.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setMethod}\NormalTok{(}\StringTok{".createObservers"}\NormalTok{, }\StringTok{"RedDimHexPlot"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x, se, input, session, pObjects, rObjects) \{}
    \KeywordTok{callNextMethod}\NormalTok{()}

\NormalTok{    plot_name <-}\StringTok{ }\KeywordTok{.getEncodedName}\NormalTok{(x)}

    \KeywordTok{.createUnprotectedParameterObservers}\NormalTok{(plot_name,}
        \DataTypeTok{fields=}\KeywordTok{c}\NormalTok{(}\StringTok{"BinResolution"}\NormalTok{),}
        \DataTypeTok{input=}\NormalTok{input, }\DataTypeTok{pObjects=}\NormalTok{pObjects, }\DataTypeTok{rObjects=}\NormalTok{rObjects)}

    \KeywordTok{invisible}\NormalTok{(}\OtherTok{NULL}\NormalTok{)}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

\hypertarget{generating-the-plot}{%
\section{Generating the plot}\label{generating-the-plot}}

We create a method for the \texttt{.generateDotPlot()} generic to implement our hexbinning strategy.
The contract for this generic guarantees that our method can immediately rely on the \texttt{plot.data} data-frame that is computed by methods defined for the parent \texttt{ReducedDimensionPlot} class.
We also use the precomputed aesthetic \texttt{labels} associated with each column of \texttt{plot.data}, while setting a fixed label \texttt{"Count"} for the \texttt{fill} aesthetic associated with the count of observation in each hexagonal bin.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(ggplot2)}
\KeywordTok{setMethod}\NormalTok{(}\StringTok{".generateDotPlot"}\NormalTok{, }\StringTok{"RedDimHexPlot"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x, labels, envir) \{}
\NormalTok{    plot_cmds <-}\StringTok{ }\KeywordTok{list}\NormalTok{()}
\NormalTok{    plot_cmds[[}\StringTok{"ggplot"}\NormalTok{]] <-}\StringTok{ "dot.plot <- ggplot() +"}
    
    \CommentTok{# Adding hexbins to the plot.}
\NormalTok{    plot_cmds[[}\StringTok{"hex"}\NormalTok{]] <-}\StringTok{ }\KeywordTok{sprintf}\NormalTok{(}\StringTok{"geom_hex(aes(X, Y), plot.data, bins=%s) +"}\NormalTok{, }\KeywordTok{deparse}\NormalTok{(x[[}\StringTok{"BinResolution"}\NormalTok{]]))}
\NormalTok{    plot_cmds[[}\StringTok{"labs"}\NormalTok{]] <-}\StringTok{ "labs(fill='Count') +"}
\NormalTok{    plot_cmds[[}\StringTok{"labs"}\NormalTok{]] <-}\StringTok{ }\KeywordTok{sprintf}\NormalTok{(}
        \StringTok{"labs(x='%s', y='%s', title='%s', fill='%s') +"}\NormalTok{,}
\NormalTok{        labels}\OperatorTok{$}\NormalTok{X, labels}\OperatorTok{$}\NormalTok{Y, labels}\OperatorTok{$}\NormalTok{title, }\StringTok{"Count"}
\NormalTok{        )}
\NormalTok{    plot_cmds[[}\StringTok{"theme_base"}\NormalTok{]] <-}\StringTok{ "theme_bw() +"}
\NormalTok{    plot_cmds[[}\StringTok{"theme_legend"}\NormalTok{]] <-}\StringTok{ "theme(legend.position = 'bottom')"}

    \CommentTok{# Adding a faceting command, if applicable.}
\NormalTok{    facet_cmd <-}\StringTok{ }\KeywordTok{.addFacets}\NormalTok{(x)}
    \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{length}\NormalTok{(facet_cmd)) \{}
\NormalTok{        N <-}\StringTok{ }\KeywordTok{length}\NormalTok{(plot_cmds)}
\NormalTok{        plot_cmds[[N]] <-}\StringTok{ }\KeywordTok{paste}\NormalTok{(plot_cmds[[N]], }\StringTok{"+"}\NormalTok{)}
\NormalTok{        plot_cmds <-}\StringTok{ }\KeywordTok{c}\NormalTok{(plot_cmds, facet_cmd)}
\NormalTok{    \}}

    \CommentTok{# Adding self-brushing boxes, if they exist.}
\NormalTok{    plot_cmds <-}\StringTok{ }\KeywordTok{.addMultiSelectionPlotCommands}\NormalTok{(x,}
        \DataTypeTok{envir=}\NormalTok{envir, }\DataTypeTok{commands=}\NormalTok{plot_cmds)}

\NormalTok{    gg_plot <-}\StringTok{ }\KeywordTok{.textEval}\NormalTok{(plot_cmds, envir)}

    \KeywordTok{list}\NormalTok{(}\DataTypeTok{plot=}\NormalTok{gg_plot, }\DataTypeTok{commands=}\NormalTok{plot_cmds)}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

For brevity, we have omitted the more tiresome parts of coloring the bins with respect to assay values or metadata variables, ensuring that the plot boundaries do not change upon receiving a restricted selection, etc.
However, it is relatively straightforward to extend \texttt{.generateDotPlot()} to ensure that it responds to such choices as well as any other relevant parameters in \texttt{x} (e.g., font size).

\hypertarget{in-action}{%
\section{In action}\label{in-action}}

To demonstrate, we will load a small example dataset \citep{tasic2016adult} from the \emph{\href{https://bioconductor.org/packages/3.12/scRNAseq}{scRNAseq}} package.
This is provided as a \texttt{SingleCellExperiment} on which we compute the usual \(t\)-SNE plot.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(scRNAseq)}
\NormalTok{sce <-}\StringTok{ }\KeywordTok{ReprocessedAllenData}\NormalTok{(}\DataTypeTok{assays=}\StringTok{"tophat_counts"}\NormalTok{)}

\KeywordTok{set.seed}\NormalTok{(}\DecValTok{100}\NormalTok{)}
\KeywordTok{library}\NormalTok{(scater)}
\NormalTok{sce <-}\StringTok{ }\KeywordTok{logNormCounts}\NormalTok{(sce, }\DataTypeTok{exprs_values=}\StringTok{"tophat_counts"}\NormalTok{)}
\NormalTok{sce <-}\StringTok{ }\KeywordTok{runPCA}\NormalTok{(sce, }\DataTypeTok{ncomponents=}\DecValTok{4}\NormalTok{)}
\NormalTok{sce <-}\StringTok{ }\KeywordTok{runTSNE}\NormalTok{(sce)}
\end{Highlighting}
\end{Shaded}

We now set up an \texttt{iSEE()} instance with the hexbin and standard plots for showing reduced dimension results.
We can see the obvious visual differences in the aesthetics between plots as well as the changes to the user interface.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{app <-}\StringTok{ }\KeywordTok{iSEE}\NormalTok{(sce, }\DataTypeTok{initial=}\KeywordTok{list}\NormalTok{(}
    \KeywordTok{ReducedDimensionPlot}\NormalTok{(}\DataTypeTok{Type=}\StringTok{"TSNE"}\NormalTok{, }\DataTypeTok{VisualBoxOpen=}\OtherTok{TRUE}\NormalTok{, }\DataTypeTok{VisualChoices=}\StringTok{"Size"}\NormalTok{, }\DataTypeTok{PanelWidth=}\NormalTok{6L),}
    \KeywordTok{RedDimHexPlot}\NormalTok{(}\DataTypeTok{Type=}\StringTok{"TSNE"}\NormalTok{, }\DataTypeTok{VisualBoxOpen=}\OtherTok{TRUE}\NormalTok{, }\DataTypeTok{VisualChoices=}\StringTok{"Size"}\NormalTok{, }\DataTypeTok{PanelWidth=}\NormalTok{6L)}
\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\includegraphics[width=1\linewidth]{screenshots/hex-dimred}

\hypertarget{dynamic-reduced-dimensions}{%
\chapter{Dynamic reduced dimensions}\label{dynamic-reduced-dimensions}}

\hypertarget{overview}{%
\section{Overview}\label{overview}}

In this case study, we will create a custom panel class to regenerate low-dimensional sample coordinates, using only a subset of points transmitted as a multiple column selection from another panel.
We call this a ``dynamic reduced dimension plot'' as it is dynamically recomputing the dimensionality reduction rather than using pre-computed values in the \texttt{reducedDims()} slot of a \texttt{SingleCellExperiment} object.
This proposed class is the basis of the \texttt{DynamicReducedDimensionPlot} from the \emph{\href{https://bioconductor.org/packages/3.12/iSEEu}{iSEEu}} package.

\hypertarget{class-basics}{%
\section{Class basics}\label{class-basics}}

First, we define the basics of our new \texttt{Panel} class.
As our new class will be showing each sample as a point, we inherit from the \texttt{ColumnDotPlot} virtual class.
This automatically gives us access to all the functionality promised by the parent,
including interface elements and observers to handle multiple selections and respond to aesthetic parameters.

We add a slot specifying the type of dimensionality reduction result and the number of highly variable genes to use.
Any new slots should also come with validity methods, as shown below.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(S4Vectors)}
\NormalTok{allowable.dim <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"PCA"}\NormalTok{, }\StringTok{"TSNE"}\NormalTok{, }\StringTok{"UMAP"}\NormalTok{)}

\KeywordTok{setValidity2}\NormalTok{(}\StringTok{"DynRedDimPlot"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(object) \{}
\NormalTok{    msg <-}\StringTok{ }\KeywordTok{character}\NormalTok{(}\DecValTok{0}\NormalTok{)}

\NormalTok{    msg <-}\StringTok{ }\KeywordTok{.validNumberError}\NormalTok{(msg, object, }\StringTok{"NGenes"}\NormalTok{, }\DataTypeTok{lower=}\DecValTok{1}\NormalTok{, }\DataTypeTok{upper=}\OtherTok{Inf}\NormalTok{) }\CommentTok{# must be a positive integer}

\NormalTok{    msg <-}\StringTok{ }\KeywordTok{.allowableChoiceError}\NormalTok{(msg, object, }\StringTok{"Type"}\NormalTok{, allowable.dim)}

    \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{length}\NormalTok{(msg)) \{}
        \KeywordTok{return}\NormalTok{(msg)}
\NormalTok{    \}}
    \OtherTok{TRUE}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

We specialize the \texttt{initialize()} method to provide a default for new parameters.
We also implement a constructor for instances of this class.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setMethod}\NormalTok{(}\StringTok{"initialize"}\NormalTok{, }\StringTok{"DynRedDimPlot"}\NormalTok{, }
    \ControlFlowTok{function}\NormalTok{(.Object, }\DataTypeTok{Type=}\StringTok{"PCA"}\NormalTok{, }\DataTypeTok{NGenes=}\NormalTok{1000L, ...) }
\NormalTok{\{}
    \KeywordTok{callNextMethod}\NormalTok{(.Object, }\DataTypeTok{Type=}\NormalTok{Type, }\DataTypeTok{NGenes=}\NormalTok{NGenes, ...)}
\NormalTok{\})}

\NormalTok{DynRedDimPlot <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(...) \{}
    \KeywordTok{new}\NormalTok{(}\StringTok{"DynRedDimPlot"}\NormalTok{, ...)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{setting-up-the-interface}{%
\section{Setting up the interface}\label{setting-up-the-interface}}

The most basic requirement is to define some methods that describe our new panel in the \texttt{iSEE()} interface.
This includes defining the full name and desired default color for display purposes:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setMethod}\NormalTok{(}\StringTok{".fullName"}\NormalTok{, }\StringTok{"DynRedDimPlot"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x) }\StringTok{"Dynamic reduced dimension plot"}\NormalTok{)}

\KeywordTok{setMethod}\NormalTok{(}\StringTok{".panelColor"}\NormalTok{, }\StringTok{"DynRedDimPlot"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x) }\StringTok{"#0F0F0F"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

We also add interface elements to change the result type and the number of genes.
This is most easily done by specializing the \texttt{.defineDataInterface} method:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(shiny)}
\KeywordTok{setMethod}\NormalTok{(}\StringTok{".defineDataInterface"}\NormalTok{, }\StringTok{"DynRedDimPlot"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x, se, select_info) \{}
\NormalTok{    plot_name <-}\StringTok{ }\KeywordTok{.getEncodedName}\NormalTok{(x)}

    \KeywordTok{list}\NormalTok{(}
        \KeywordTok{selectInput}\NormalTok{(}\KeywordTok{paste0}\NormalTok{(plot_name, }\StringTok{"_Type"}\NormalTok{), }\DataTypeTok{label=}\StringTok{"Type:"}\NormalTok{,}
            \DataTypeTok{choices=}\NormalTok{allowable.dim, }\DataTypeTok{selected=}\NormalTok{x[[}\StringTok{"Type"}\NormalTok{]]),}
        \KeywordTok{numericInput}\NormalTok{(}\KeywordTok{paste0}\NormalTok{(plot_name, }\StringTok{"_NGenes"}\NormalTok{), }\DataTypeTok{label=}\StringTok{"Number of HVGs:"}\NormalTok{,}
            \DataTypeTok{min=}\DecValTok{1}\NormalTok{, }\DataTypeTok{value=}\NormalTok{x[[}\StringTok{"NGenes"}\NormalTok{]])}
\NormalTok{    )}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

We call \texttt{.getEncodedName()} to obtain a unique name for the current instance of our panel, e.g., \texttt{DynRedDimPlot1}.
We then \texttt{paste0} the name of our panel to the name of any parameter to ensure that the ID is unique to this instance of our panel;
otherwise, observers for multiple \texttt{DynRedDimPlot}s would override each other.
One can imagine this as a poor man's Shiny module.

\hypertarget{creating-the-observers}{%
\section{Creating the observers}\label{creating-the-observers}}

We specialize \texttt{.createObservers()} to define some observers to respond to changes in our new interface elements.
Note the use of \texttt{callNextMethod()} to ensure that observers of the parent class are also created;
this automatically ensures that we can respond to changes in parameters provided by \texttt{ColumnDotPlot}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setMethod}\NormalTok{(}\StringTok{".createObservers"}\NormalTok{, }\StringTok{"DynRedDimPlot"}\NormalTok{, }
    \ControlFlowTok{function}\NormalTok{(x, se, input, session, pObjects, rObjects) }
\NormalTok{\{}
    \KeywordTok{callNextMethod}\NormalTok{()}

\NormalTok{    plot_name <-}\StringTok{ }\KeywordTok{.getEncodedName}\NormalTok{(x)}

    \KeywordTok{.createProtectedParameterObservers}\NormalTok{(plot_name,}
        \DataTypeTok{fields=}\KeywordTok{c}\NormalTok{(}\StringTok{"Type"}\NormalTok{, }\StringTok{"NGenes"}\NormalTok{),}
        \DataTypeTok{input=}\NormalTok{input, }\DataTypeTok{pObjects=}\NormalTok{pObjects, }\DataTypeTok{rObjects=}\NormalTok{rObjects)}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

Both the \texttt{NGenes} and \texttt{Type} parameters are what we consider to be ``protected'' parameters,
as changing them will alter the nature of the displayed plot.
We use the \texttt{.createProtectedParameterObservers()} utility to set up observers for both parameters,
which will instruct \texttt{iSEE()} to destroy existing brushes and lassos when these parameters are changed.
The idea here is that brushes/lassos made on the previous plot do not make sense when the coordinates are recomputed.

For this particular panel class, an additional helpful feature is to override \texttt{.multiSelectionInvalidated}.
This indicates that any brushes or lassos in our plot should be destroyed when we receive a new column selection.
Doing so is the only sensible course of action as the reduced dimension coordinates for one set of samples have no obvious relationship to the coordinates for another set of samples;
having old brushes or lassos hanging around would be of no benefit at best, and be misleading at worst.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setMethod}\NormalTok{(}\StringTok{".multiSelectionInvalidated"}\NormalTok{, }\StringTok{"DynRedDimPlot"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x) }\OtherTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{making-the-plot}{%
\section{Making the plot}\label{making-the-plot}}

When working with a \texttt{ColumnDotPlot} subclass, the easiest way to change plotting content to override the \texttt{.generateDotPlotData()} method.
This should add a \texttt{plot.data} variable to the \texttt{envir} environment that has columns \texttt{X} and \texttt{Y} and contains one row per column of the original \texttt{SummarizedExperiment}.
It should also return a character vector of R commands describing how that \texttt{plot.data} object was constructed.
The easiest way to do this is to create a character vector of commands and call \texttt{eval(parse(text=...),\ envir=envir)} to evaluate them within \texttt{envir}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setMethod}\NormalTok{(}\StringTok{".generateDotPlotData"}\NormalTok{, }\StringTok{"DynRedDimPlot"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x, envir) \{}
\NormalTok{    commands <-}\StringTok{ }\KeywordTok{character}\NormalTok{(}\DecValTok{0}\NormalTok{)}

    \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{exists}\NormalTok{(}\StringTok{"col_selected"}\NormalTok{, }\DataTypeTok{envir=}\NormalTok{envir, }\DataTypeTok{inherits=}\OtherTok{FALSE}\NormalTok{)) \{}
\NormalTok{        commands <-}\StringTok{ }\KeywordTok{c}\NormalTok{(commands, }
            \StringTok{"plot.data <- data.frame(X=numeric(0), Y=numeric(0));"}\NormalTok{)}
\NormalTok{    \} }\ControlFlowTok{else}\NormalTok{ \{}
\NormalTok{        commands <-}\StringTok{ }\KeywordTok{c}\NormalTok{(commands,}
            \StringTok{".chosen <- unique(unlist(col_selected));"}\NormalTok{,}
            \StringTok{"set.seed(100000)"}\NormalTok{, }\CommentTok{# to avoid problems with randomization.}
            \KeywordTok{sprintf}\NormalTok{(}\StringTok{".coords <- scater::calculate%s(se[,.chosen], ntop=%i, ncomponents=2);"}\NormalTok{,}
\NormalTok{                x[[}\StringTok{"Type"}\NormalTok{]], x[[}\StringTok{"NGenes"}\NormalTok{]]),}
            \StringTok{"plot.data <- data.frame(.coords, row.names=.chosen);"}\NormalTok{,}
            \StringTok{"colnames(plot.data) <- c('X', 'Y');"}
\NormalTok{        )}
\NormalTok{    \}}

\NormalTok{    commands <-}\StringTok{ }\KeywordTok{c}\NormalTok{(commands,}
        \StringTok{"plot.data <- plot.data[colnames(se),,drop=FALSE];"}\NormalTok{,}
        \StringTok{"rownames(plot.data) <- colnames(se);"}\NormalTok{)}

    \KeywordTok{eval}\NormalTok{(}\KeywordTok{parse}\NormalTok{(}\DataTypeTok{text=}\NormalTok{commands), }\DataTypeTok{envir=}\NormalTok{envir)}

    \KeywordTok{list}\NormalTok{(}\DataTypeTok{data_cmds=}\NormalTok{commands, }\DataTypeTok{plot_title=}\KeywordTok{sprintf}\NormalTok{(}\StringTok{"Dynamic %s plot"}\NormalTok{, x[[}\StringTok{"Type"}\NormalTok{]]), }
        \DataTypeTok{x_lab=}\KeywordTok{paste0}\NormalTok{(x[[}\StringTok{"Type"}\NormalTok{]], }\StringTok{"1"}\NormalTok{), }\DataTypeTok{y_lab=}\KeywordTok{paste0}\NormalTok{(x[[}\StringTok{"Type"}\NormalTok{]], }\StringTok{"2"}\NormalTok{))}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

We use functions from the \emph{\href{https://bioconductor.org/packages/3.12/scater}{scater}} package to do the actual heavy lifting of calculating the dimensionality reduction results.
The \texttt{exists()} call will check whether any column selection is being transmitted to this panel; if not, it will just return a \texttt{plot.data} variable that contains all \texttt{NA}s such that an empty plot is created.
If \texttt{col\_selected} does exist, it will contain a list of character vectors specifying the active and saved multiple selections that are being transmitted.
For this particular example, we do not care about the distinction between active/saved selections so we just take the union of all of them.

Of course, this is not quite the most efficient way to implement a plotting panel that involves recomputation.
A better approach would be to cache the x/y coordinates and reuse them if only aesthetic parameters have changed,
thus avoiding an unnecessary delay from recomputation.
Doing so requires overriding \texttt{.renderOutput()} to take advantage of the cached contents of the plot,
so we will omit that here for simplicity.

\hypertarget{in-action}{%
\section{In action}\label{in-action}}

Let's put our new panel to the test.
We'll use the \texttt{sce} object from Chapter \ref{developing}, which includes some precomputed dimensionality reduction results.
The plan is to create a (fixed) reduced dimension plot that will transmit a multiple selection to our dynamic reduced dimension plot.
Brushing at any location in the former will then trigger dynamic recompution of results in the latter.
We demonstrate by initializing the app with an existing brush, though in real usage, users will interactive create the brush themselves.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{rdp <-}\StringTok{ }\KeywordTok{ReducedDimensionPlot}\NormalTok{(}\DataTypeTok{PanelId=}\NormalTok{1L, }\DataTypeTok{PanelWidth=}\NormalTok{6L,}
    \DataTypeTok{BrushData =} \KeywordTok{list}\NormalTok{(}
        \DataTypeTok{xmin =} \DecValTok{17}\NormalTok{, }\DataTypeTok{xmax =} \DecValTok{55}\NormalTok{, }\DataTypeTok{ymin =} \DecValTok{-36}\NormalTok{, }\DataTypeTok{ymax =} \DecValTok{29}\NormalTok{,}
        \DataTypeTok{coords_css =} \KeywordTok{list}\NormalTok{(}\DataTypeTok{xmin =}\NormalTok{ 300L, }\DataTypeTok{xmax =}\NormalTok{ 450L, }\DataTypeTok{ymin =}\NormalTok{ 170L, }\DataTypeTok{ymax =}\NormalTok{ 404L),}
        \DataTypeTok{coords_img =} \KeywordTok{list}\NormalTok{( }\DataTypeTok{xmin =}\NormalTok{ 375L, }\DataTypeTok{xmax =} \DecValTok{562}\NormalTok{, }\DataTypeTok{ymin =} \DecValTok{212}\NormalTok{, }\DataTypeTok{ymax =}\NormalTok{ 505L),}
        \DataTypeTok{img_css_ratio =} \KeywordTok{list}\NormalTok{(}\DataTypeTok{x =} \DecValTok{1}\NormalTok{, }\DataTypeTok{y =} \DecValTok{1}\NormalTok{),}
        \DataTypeTok{mapping =} \KeywordTok{list}\NormalTok{(}\DataTypeTok{x =} \StringTok{"X"}\NormalTok{, }\DataTypeTok{y =} \StringTok{"Y"}\NormalTok{),}
        \DataTypeTok{domain =} \KeywordTok{list}\NormalTok{(}\DataTypeTok{left =} \DecValTok{-49}\NormalTok{, }\DataTypeTok{right =} \DecValTok{57}\NormalTok{, }\DataTypeTok{bottom =} \DecValTok{-53}\NormalTok{, }\DataTypeTok{top =} \DecValTok{70}\NormalTok{),}
        \DataTypeTok{range =} \KeywordTok{list}\NormalTok{(}\DataTypeTok{left =} \DecValTok{49}\NormalTok{, }\DataTypeTok{right =} \DecValTok{570}\NormalTok{, }\DataTypeTok{bottom =} \DecValTok{580}\NormalTok{, }\DataTypeTok{top =} \DecValTok{31}\NormalTok{),}
        \DataTypeTok{log =} \KeywordTok{list}\NormalTok{(}\DataTypeTok{x =} \OtherTok{NULL}\NormalTok{, }\DataTypeTok{y =} \OtherTok{NULL}\NormalTok{),}
        \DataTypeTok{direction =} \StringTok{"xy"}\NormalTok{, }\DataTypeTok{brushId =} \StringTok{"ReducedDimensionPlot1_Brush"}\NormalTok{,}
        \DataTypeTok{outputId =} \StringTok{"ReducedDimensionPlot1"}
\NormalTok{    )}
\NormalTok{)}

\NormalTok{drdp <-}\StringTok{ }\KeywordTok{DynRedDimPlot}\NormalTok{(}\DataTypeTok{DataBoxOpen=}\OtherTok{TRUE}\NormalTok{, }\DataTypeTok{ColumnSelectionSource=}\StringTok{"ReducedDimensionPlot1"}\NormalTok{, }\DataTypeTok{PanelWidth=}\NormalTok{6L)}
\NormalTok{app <-}\StringTok{ }\KeywordTok{iSEE}\NormalTok{(sce, }\DataTypeTok{initial=}\KeywordTok{list}\NormalTok{(rdp, drdp))}
\end{Highlighting}
\end{Shaded}

\includegraphics[width=1\linewidth]{screenshots/adaptive-dimred}

\hypertarget{dynamic-differential-expression}{%
\chapter{Dynamic differential expression}\label{dynamic-differential-expression}}

\hypertarget{overview}{%
\section{Overview}\label{overview}}

In this case study, we will create a panel class to dynamically compute differential expression (DE) statistics between the active sample-level selection and the other saved selections from a transmitting panel.
We will present the results of this computation in a \texttt{DataTable} widget from the \emph{\href{https://CRAN.R-project.org/package=DT}{DT}} package, where each row is a gene and each column is a relevant statistic (\(p\)-value, FDR, log-fold changes, etc.).
The class proposed here is the basis of the \texttt{DifferentialStatsticsTable} from \emph{\href{https://bioconductor.org/packages/3.12/iSEEu}{iSEEu}}.

\hypertarget{class-basics}{%
\section{Class basics}\label{class-basics}}

First, we define the basics of our new \texttt{Panel} class.
As our new class will be showing each gene as a row, we inherit from the \texttt{RowTable} virtual class.
This automatically gives us access to all the functionality promised by the parent,
including interface elements and observers to respond to multiple selections.
We also add a slot specifying the log-fold change threshold to use in the null hypothesis.

Any new slots should come with validity methods, as shown below.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(S4Vectors)}
\KeywordTok{setValidity2}\NormalTok{(}\StringTok{"DGETable"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(object) \{}
\NormalTok{    msg <-}\StringTok{ }\KeywordTok{character}\NormalTok{(}\DecValTok{0}\NormalTok{)}

\NormalTok{    msg <-}\StringTok{ }\KeywordTok{.validNumberError}\NormalTok{(msg, object, }\StringTok{"LogFC"}\NormalTok{, }\DataTypeTok{lower=}\DecValTok{0}\NormalTok{, }\DataTypeTok{upper=}\OtherTok{Inf}\NormalTok{) }\CommentTok{# must be non-negative.}

    \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{length}\NormalTok{(msg)) \{}
        \KeywordTok{return}\NormalTok{(msg)}
\NormalTok{    \}}
    \OtherTok{TRUE}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

It is also worthwhile specializing the \texttt{initialize()} method to provide a default for new parameters.
We hard-code the \texttt{ColumnSelectionType} setting as we want to obtain all multiple selections from the transmitting panel,
in order to be able to perform pairwise DE analyses between the various active and saved selections.
(By comparison, the default of \texttt{"Active"} will only transmit the current active selection.)
We also define a constructor to conveniently create new instances.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setMethod}\NormalTok{(}\StringTok{"initialize"}\NormalTok{, }\StringTok{"DGETable"}\NormalTok{, }
    \ControlFlowTok{function}\NormalTok{(.Object, }\DataTypeTok{LogFC=}\DecValTok{0}\NormalTok{, ...) }
\NormalTok{\{}
    \KeywordTok{callNextMethod}\NormalTok{(.Object, }\DataTypeTok{LogFC=}\NormalTok{LogFC, }\DataTypeTok{ColumnSelectionType=}\StringTok{"Union"}\NormalTok{, ...)}
\NormalTok{\})}

\NormalTok{DGETable <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(...) \{}
    \KeywordTok{new}\NormalTok{(}\StringTok{"DGETable"}\NormalTok{, ...)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{setting-up-the-interface}{%
\section{Setting up the interface}\label{setting-up-the-interface}}

The most basic requirement is to define some methods that describe our new panel in the \texttt{iSEE()} interface.
This includes defining the full name and desired default color for display purposes:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setMethod}\NormalTok{(}\StringTok{".fullName"}\NormalTok{, }\StringTok{"DGETable"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x) }\StringTok{"Differential expression table"}\NormalTok{)}

\KeywordTok{setMethod}\NormalTok{(}\StringTok{".panelColor"}\NormalTok{, }\StringTok{"DGETable"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x) }\StringTok{"#55AA00"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

We also add interface elements to change the result type and the number of genes.
This is most easily done by specializing the \texttt{.defineDataInterface()} generic.
We \texttt{paste0} the name of our panel to the name of any parameter to ensure that the ID is unique to this instance of our panel.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(shiny)}
\KeywordTok{setMethod}\NormalTok{(}\StringTok{".defineDataInterface"}\NormalTok{, }\StringTok{"DGETable"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x, se, select_info) \{}
\NormalTok{    plot_name <-}\StringTok{ }\KeywordTok{.getEncodedName}\NormalTok{(x)}
    \KeywordTok{list}\NormalTok{(}
        \KeywordTok{numericInput}\NormalTok{(}\KeywordTok{paste0}\NormalTok{(plot_name, }\StringTok{"_LogFC"}\NormalTok{), }\DataTypeTok{label=}\StringTok{"Log-FC threshold"}\NormalTok{,}
            \DataTypeTok{min=}\DecValTok{0}\NormalTok{, }\DataTypeTok{value=}\NormalTok{x[[}\StringTok{"LogFC"}\NormalTok{]])}
\NormalTok{    )}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

By default, all \texttt{RowTable}s hide their multiple column selection parameter choices.
This is motivated by the typical use case where \texttt{RowTable}s respond to a selection of rows rather than a selection of columns.
For \texttt{DGETable}s, we need to flip this around by specializing \texttt{.hideInterface()} so that the unresponsive row selection parameters are hidden in the interface while the useful column selection parameters are visible.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setMethod}\NormalTok{(}\StringTok{".hideInterface"}\NormalTok{, }\StringTok{"DGETable"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x, field) \{}
    \ControlFlowTok{if}\NormalTok{ (field }\OperatorTok{%in%}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"RowSelectionSource"}\NormalTok{, }\StringTok{"RowSelectionType"}\NormalTok{, }
        \StringTok{"RowSelectionSaved"}\NormalTok{, }\StringTok{"RowSelectionDynamicSource"}\NormalTok{)) \{}
        \OtherTok{TRUE}
\NormalTok{    \} }\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (field }\OperatorTok{%in%}\StringTok{ "ColumnSelectionSource"}\NormalTok{) \{}
        \OtherTok{FALSE}
\NormalTok{    \} }\ControlFlowTok{else}\NormalTok{ \{}
        \KeywordTok{callNextMethod}\NormalTok{()}
\NormalTok{    \}}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

A more advanced version of this panel class might consider responding to a row selection by only performing the DE analysis on the selected features.
In such cases, we would not need to hide \texttt{RowSelectionSource}, though we will leave that as an exercise for the curious.

\hypertarget{creating-the-observers}{%
\section{Creating the observers}\label{creating-the-observers}}

We specialize \texttt{.createObservers} to define some observers to respond to changes in our new interface elements.
Note the use of \texttt{callNextMethod()} to ensure that observers of the parent class are also created;
this automatically ensures that we can respond to changes in parameters provided by \texttt{RowTable}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setMethod}\NormalTok{(}\StringTok{".createObservers"}\NormalTok{, }\StringTok{"DGETable"}\NormalTok{, }
    \ControlFlowTok{function}\NormalTok{(x, se, input, session, pObjects, rObjects) }
\NormalTok{\{}
    \KeywordTok{callNextMethod}\NormalTok{()}

\NormalTok{    plot_name <-}\StringTok{ }\KeywordTok{.getEncodedName}\NormalTok{(x)}

    \KeywordTok{.createUnprotectedParameterObservers}\NormalTok{(plot_name,}
        \DataTypeTok{fields=}\StringTok{"LogFC"}\NormalTok{,}
        \DataTypeTok{input=}\NormalTok{input, }\DataTypeTok{pObjects=}\NormalTok{pObjects, }\DataTypeTok{rObjects=}\NormalTok{rObjects)}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

The distinction between protected and unprotected parameters is less important for \texttt{Table}s;
as long as the types of the columns do not change between renderings, any column or global selections (i.e., search terms) are usually still sensible.

\hypertarget{making-the-table}{%
\section{Making the table}\label{making-the-table}}

When working with a \texttt{RowTable} subclass, the easiest way to change plotting content to override the \texttt{.generateTable()} method.
This is expected to generate a \texttt{data.frame} in the evaluation environment, returning the commands required to do so.
In this case, we want to perform one-sided \(t\)-tests between the active selection and any number of saved selections.
We will use the \texttt{findMarkers()} function from \emph{\href{https://bioconductor.org/packages/3.12/scran}{scran}} to compute the desired statistics.
This performs all pairwise comparisons rather than just those involving the active selection,
so is not as efficient as could be, but it will suffice for this demonstration.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setMethod}\NormalTok{(}\StringTok{".generateTable"}\NormalTok{, }\StringTok{"DGETable"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x, envir) \{}
\NormalTok{    empty <-}\StringTok{ "tab <- data.frame(Top=integer(0), p.value=numeric(0), FDR=numeric(0));"}

    \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{exists}\NormalTok{(}\StringTok{"col_selected"}\NormalTok{, envir, }\DataTypeTok{inherits=}\OtherTok{FALSE}\NormalTok{) }\OperatorTok{||}\StringTok{ }
\StringTok{        }\KeywordTok{length}\NormalTok{(envir}\OperatorTok{$}\NormalTok{col_selected)}\OperatorTok{<}\NormalTok{2L }\OperatorTok{||}\StringTok{ }
\StringTok{        }\OperatorTok{!}\StringTok{"active"} \OperatorTok{%in%}\StringTok{ }\KeywordTok{names}\NormalTok{(envir}\OperatorTok{$}\NormalTok{col_selected)) }
\NormalTok{    \{}
\NormalTok{        commands <-}\StringTok{ }\NormalTok{empty}
\NormalTok{    \} }\ControlFlowTok{else}\NormalTok{ \{}
\NormalTok{        commands <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{".chosen <- unlist(col_selected);"}\NormalTok{,}
            \StringTok{".grouping <- rep(names(col_selected), lengths(col_selected));"}\NormalTok{,}
            \KeywordTok{sprintf}\NormalTok{(}\StringTok{".de.stats <- scran::findMarkers(logcounts(se)[,.chosen], }
\StringTok{    .grouping, direction='up', lfc=%s)"}\NormalTok{, x[[}\StringTok{"LogFC"}\NormalTok{]]),}
            \StringTok{"tab <- as.data.frame(.de.stats[['active']]);"}
\NormalTok{        )}
\NormalTok{    \}}
       
    \KeywordTok{eval}\NormalTok{(}\KeywordTok{parse}\NormalTok{(}\DataTypeTok{text=}\NormalTok{commands), }\DataTypeTok{envir=}\NormalTok{envir)}

    \KeywordTok{list}\NormalTok{(}\DataTypeTok{commands=}\NormalTok{commands, }\DataTypeTok{contents=}\NormalTok{envir}\OperatorTok{$}\NormalTok{tab)}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

Readers may notice that we prefix internal variables with \texttt{.} in our commands.
This ensures that they do not clash with global variables created by \texttt{iSEE()} itself
(which is not an issue when running the app, but makes things difficult when the code is reported for tracking purposes).

\hypertarget{in-action}{%
\section{In action}\label{in-action}}

Let's put our new panel to the test.
We'll use the \texttt{sce} object from Chapter \ref{developing}, which includes some precomputed dimensionality reduction results.
The plan is to create a (fixed) reduced dimension plot that will transmit to our DGE table.
We set up an iSEE instance with an existing brush on the former to trigger computation of differential results by the latter.
In practice, of course, the brushes will be created by the user and do not have to be explicitly defined during initialization.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Setting up multiple active and saved brushes.}
\NormalTok{rdp <-}\StringTok{ }\KeywordTok{ReducedDimensionPlot}\NormalTok{(}\DataTypeTok{PanelId=}\NormalTok{1L,}
    \DataTypeTok{BrushData =} \KeywordTok{list}\NormalTok{(}
        \DataTypeTok{xmin =} \DecValTok{17}\NormalTok{, }\DataTypeTok{xmax =} \DecValTok{55}\NormalTok{, }\DataTypeTok{ymin =} \DecValTok{-36}\NormalTok{, }\DataTypeTok{ymax =} \DecValTok{29}\NormalTok{, }
        \DataTypeTok{coords_css =} \KeywordTok{list}\NormalTok{(}\DataTypeTok{xmin =}\NormalTok{ 300L, }\DataTypeTok{xmax =}\NormalTok{ 450L, }\DataTypeTok{ymin =}\NormalTok{ 170L, }\DataTypeTok{ymax =}\NormalTok{ 404L), }
        \DataTypeTok{coords_img =} \KeywordTok{list}\NormalTok{( }\DataTypeTok{xmin =}\NormalTok{ 375L, }\DataTypeTok{xmax =} \DecValTok{562}\NormalTok{, }\DataTypeTok{ymin =} \DecValTok{212}\NormalTok{, }\DataTypeTok{ymax =}\NormalTok{ 505L), }
        \DataTypeTok{img_css_ratio =} \KeywordTok{list}\NormalTok{(}\DataTypeTok{x =} \DecValTok{1}\NormalTok{, }\DataTypeTok{y =} \DecValTok{1}\NormalTok{), }
        \DataTypeTok{mapping =} \KeywordTok{list}\NormalTok{(}\DataTypeTok{x =} \StringTok{"X"}\NormalTok{, }\DataTypeTok{y =} \StringTok{"Y"}\NormalTok{), }
        \DataTypeTok{domain =} \KeywordTok{list}\NormalTok{(}\DataTypeTok{left =} \DecValTok{-49}\NormalTok{, }\DataTypeTok{right =} \DecValTok{57}\NormalTok{, }\DataTypeTok{bottom =} \DecValTok{-53}\NormalTok{, }\DataTypeTok{top =} \DecValTok{70}\NormalTok{), }
        \DataTypeTok{range =} \KeywordTok{list}\NormalTok{(}\DataTypeTok{left =} \DecValTok{49}\NormalTok{, }\DataTypeTok{right =} \DecValTok{570}\NormalTok{, }\DataTypeTok{bottom =} \DecValTok{580}\NormalTok{, }\DataTypeTok{top =} \DecValTok{31}\NormalTok{), }
        \DataTypeTok{log =} \KeywordTok{list}\NormalTok{(}\DataTypeTok{x =} \OtherTok{NULL}\NormalTok{, }\DataTypeTok{y =} \OtherTok{NULL}\NormalTok{), }
        \DataTypeTok{direction =} \StringTok{"xy"}\NormalTok{, }\DataTypeTok{brushId =} \StringTok{"ReducedDimensionPlot1_Brush"}\NormalTok{, }
        \DataTypeTok{outputId =} \StringTok{"ReducedDimensionPlot1"}
\NormalTok{    ),}
    \DataTypeTok{SelectionHistory =} \KeywordTok{list}\NormalTok{(}
        \KeywordTok{list}\NormalTok{(}
            \DataTypeTok{xmin =} \DecValTok{-44}\NormalTok{, }\DataTypeTok{xmax =} \DecValTok{-1}\NormalTok{, }\DataTypeTok{ymin =} \DecValTok{5}\NormalTok{, }\DataTypeTok{ymax =} \DecValTok{59}\NormalTok{, }
            \DataTypeTok{coords_css =} \KeywordTok{list}\NormalTok{(}\DataTypeTok{xmin =}\NormalTok{ 57L, }\DataTypeTok{xmax =}\NormalTok{ 225L, }\DataTypeTok{ymin =}\NormalTok{ 64L, }\DataTypeTok{ymax =}\NormalTok{ 254L), }
            \DataTypeTok{coords_img =} \KeywordTok{list}\NormalTok{(}\DataTypeTok{xmin =} \DecValTok{71}\NormalTok{, }\DataTypeTok{xmax =} \DecValTok{281}\NormalTok{, }\DataTypeTok{ymin =}\NormalTok{ 80L, }\DataTypeTok{ymax =} \DecValTok{317}\NormalTok{), }
            \DataTypeTok{img_css_ratio =} \KeywordTok{list}\NormalTok{(}\DataTypeTok{x =} \DecValTok{1}\NormalTok{, }\DataTypeTok{y =} \DecValTok{1}\NormalTok{), }
            \DataTypeTok{mapping =} \KeywordTok{list}\NormalTok{(}\DataTypeTok{x =} \StringTok{"X"}\NormalTok{, }\DataTypeTok{y =} \StringTok{"Y"}\NormalTok{), }
            \DataTypeTok{domain =} \KeywordTok{list}\NormalTok{(}\DataTypeTok{left =} \DecValTok{-49}\NormalTok{, }\DataTypeTok{right =} \DecValTok{57}\NormalTok{, }\DataTypeTok{bottom =} \DecValTok{-53}\NormalTok{, }\DataTypeTok{top =} \DecValTok{70}\NormalTok{), }
            \DataTypeTok{range =} \KeywordTok{list}\NormalTok{(}\DataTypeTok{left =} \DecValTok{49}\NormalTok{, }\DataTypeTok{right =} \DecValTok{570}\NormalTok{, }\DataTypeTok{bottom =} \DecValTok{580}\NormalTok{, }\DataTypeTok{top =} \DecValTok{31}\NormalTok{), }
            \DataTypeTok{log =} \KeywordTok{list}\NormalTok{(}\DataTypeTok{x =} \OtherTok{NULL}\NormalTok{, }\DataTypeTok{y =} \OtherTok{NULL}\NormalTok{), }
            \DataTypeTok{direction =} \StringTok{"xy"}\NormalTok{, }\DataTypeTok{brushId =} \StringTok{"ReducedDimensionPlot1_Brush"}\NormalTok{, }
            \DataTypeTok{outputId =} \StringTok{"ReducedDimensionPlot1"}
\NormalTok{        )}
\NormalTok{    )}
\NormalTok{) }

\NormalTok{dget <-}\StringTok{ }\KeywordTok{DGETable}\NormalTok{(}\DataTypeTok{ColumnSelectionSource=}\StringTok{"ReducedDimensionPlot1"}\NormalTok{, }
    \DataTypeTok{PanelWidth=}\NormalTok{8L, }\DataTypeTok{DataBoxOpen=}\OtherTok{TRUE}\NormalTok{)}
\NormalTok{app <-}\StringTok{ }\KeywordTok{iSEE}\NormalTok{(sce, }\DataTypeTok{initial=}\KeywordTok{list}\NormalTok{(rdp, dget))}
\end{Highlighting}
\end{Shaded}

\includegraphics[width=1\linewidth]{screenshots/de-table}

\hypertarget{annotated-gene-list}{%
\chapter{Annotated gene list}\label{annotated-gene-list}}

\hypertarget{overview}{%
\section{Overview}\label{overview}}

When given a gene list, we often need to look up the function of the top genes in a search engine.
This typically involves copy-pasting the gene name or ID into the search box and pressing Enter, which is a pain.
Instead, we can automate this process in \emph{\href{https://bioconductor.org/packages/3.12/iSEE}{iSEE}} by creating an \textbf{annotated gene table} that dynamically looks up annotation for each gene in the \texttt{rowData} of a \texttt{SummarizedExperiment}.

\hypertarget{class-basics}{%
\section{Class basics}\label{class-basics}}

First, we define the basics of our new \texttt{Panel} class.
Our new class will be showing the gene-level metadata, so we inherit from the \texttt{RowDataTable} class that does exactly this.
We add some slots specifying which column of the table contains our gene IDs, the type of ID and the organism database to use.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(iSEE)}
\KeywordTok{library}\NormalTok{(S4Vectors)}
\KeywordTok{setClass}\NormalTok{(}\StringTok{"GeneAnnoTable"}\NormalTok{, }\DataTypeTok{contains=}\StringTok{"RowDataTable"}\NormalTok{,}
    \DataTypeTok{slots=}\KeywordTok{c}\NormalTok{(}
        \DataTypeTok{IDColumn=}\StringTok{"character_OR_NULL"}\NormalTok{, }
        \DataTypeTok{IDType=}\StringTok{"character"}\NormalTok{,}
        \DataTypeTok{Organism=}\StringTok{"character"}\NormalTok{,}
        \DataTypeTok{AnnoBoxOpen=}\StringTok{"logical"}
\NormalTok{    )}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

We specialize the validity method to check that the \texttt{IDColumn} is either a string or \texttt{NULL};
if the latter, we assume that the ID is stored in the row name.
We also add some cursory checks for the other parameters.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{allowable <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"ENSEMBL"}\NormalTok{, }\StringTok{"SYMBOL"}\NormalTok{, }\StringTok{"ENTREZID"}\NormalTok{)}
\KeywordTok{setValidity2}\NormalTok{(}\StringTok{"GeneAnnoTable"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(object) \{}
\NormalTok{    msg <-}\StringTok{ }\KeywordTok{character}\NormalTok{(}\DecValTok{0}\NormalTok{)}

    \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(val <-}\StringTok{ }\NormalTok{object[[}\StringTok{"IDColumn"}\NormalTok{]])) \{}
\NormalTok{        msg <-}\StringTok{ }\KeywordTok{.validStringError}\NormalTok{(msg, object, }\StringTok{"IDColumn"}\NormalTok{)}
\NormalTok{    \}}

\NormalTok{    msg <-}\StringTok{ }\KeywordTok{.validStringError}\NormalTok{(msg, object, }\StringTok{"Organism"}\NormalTok{)}

\NormalTok{    msg <-}\StringTok{ }\KeywordTok{.allowableChoiceError}\NormalTok{(msg, object, }\StringTok{"IDType"}\NormalTok{, allowable)}

\NormalTok{    msg <-}\StringTok{ }\KeywordTok{.validLogicalError}\NormalTok{(msg, object, }\StringTok{"AnnoBoxOpen"}\NormalTok{)}

    \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{length}\NormalTok{(msg)) \{}
        \KeywordTok{return}\NormalTok{(msg)}
\NormalTok{    \}}
    \OtherTok{TRUE}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

We then specialize the initialize method to set reasonable defaults for these parameters.
We also provide a constructor to conveniently create new instances.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setMethod}\NormalTok{(}\StringTok{"initialize"}\NormalTok{, }\StringTok{"GeneAnnoTable"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(.Object, }\DataTypeTok{IDColumn=}\OtherTok{NULL}\NormalTok{, }
    \DataTypeTok{Organism=}\StringTok{"org.Mm.eg.db"}\NormalTok{, }\DataTypeTok{IDType=}\StringTok{"SYMBOL"}\NormalTok{, }\DataTypeTok{AnnoBoxOpen=}\OtherTok{FALSE}\NormalTok{, ...)}
\NormalTok{\{}
    \KeywordTok{callNextMethod}\NormalTok{(.Object, }\DataTypeTok{IDColumn=}\NormalTok{IDColumn, }\DataTypeTok{IDType=}\NormalTok{IDType,}
        \DataTypeTok{Organism=}\NormalTok{Organism, }\DataTypeTok{AnnoBoxOpen=}\NormalTok{AnnoBoxOpen, ...)}
\NormalTok{\})}

\NormalTok{GeneAnnoTable <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(...) \{}
    \KeywordTok{new}\NormalTok{(}\StringTok{"GeneAnnoTable"}\NormalTok{, ...)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{setting-up-the-interface}{%
\section{Setting up the interface}\label{setting-up-the-interface}}

We define the full name and desired default color for display purposes:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setMethod}\NormalTok{(}\StringTok{".fullName"}\NormalTok{, }\StringTok{"GeneAnnoTable"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x) }\StringTok{"Annotated gene table"}\NormalTok{)}

\KeywordTok{setMethod}\NormalTok{(}\StringTok{".panelColor"}\NormalTok{, }\StringTok{"GeneAnnoTable"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x) }\StringTok{"#AA1122"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

We want to add another UI element for showing the gene-level annotation.
This is achieved by specializing the \texttt{.defineOutput()} method as shown below;
note the prefixing by the panel name to ensure that output element IDs from different panels are unique.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setMethod}\NormalTok{(}\StringTok{".defineOutput"}\NormalTok{, }\StringTok{"GeneAnnoTable"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x, ...) \{}
\NormalTok{    panel_name <-}\StringTok{ }\KeywordTok{.getEncodedName}\NormalTok{(x)}
    \KeywordTok{tagList}\NormalTok{(}
        \KeywordTok{callNextMethod}\NormalTok{(), }\CommentTok{# Re-using RowDataTable's definition.}
        \KeywordTok{uiOutput}\NormalTok{(}\KeywordTok{paste0}\NormalTok{(panel_name, }\StringTok{"_annotation"}\NormalTok{)),}
        \KeywordTok{hr}\NormalTok{()}
\NormalTok{    )}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

We also set up interface elements for changing the annotation parameters.
We will put these elements in a separate ``Annotation parameters'' collapsible box,
which is initialized in an opened or closed state depending on the \texttt{AnnoBoxOpen} slot.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setMethod}\NormalTok{(}\StringTok{".defineInterface"}\NormalTok{, }\StringTok{"GeneAnnoTable"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x, se, select_info) \{}
\NormalTok{    panel_name <-}\StringTok{ }\KeywordTok{.getEncodedName}\NormalTok{(x)}
    \KeywordTok{c}\NormalTok{(}
        \KeywordTok{list}\NormalTok{(}
            \KeywordTok{collapseBox}\NormalTok{(}
                \KeywordTok{paste0}\NormalTok{(panel_name, }\StringTok{"_AnnoBoxOpen"}\NormalTok{),}
                \DataTypeTok{title=}\StringTok{"Annotation parameters"}\NormalTok{,}
                \DataTypeTok{open=}\NormalTok{x[[}\StringTok{"AnnoBoxOpen"}\NormalTok{]],}
                \KeywordTok{selectInput}\NormalTok{(}\KeywordTok{paste0}\NormalTok{(panel_name, }\StringTok{"_IDColumn"}\NormalTok{),}
                    \DataTypeTok{label=}\StringTok{"ID-containing column:"}\NormalTok{,}
                    \DataTypeTok{choices=}\KeywordTok{colnames}\NormalTok{(}\KeywordTok{rowData}\NormalTok{(se)), }
                    \DataTypeTok{selected=}\NormalTok{x[[}\StringTok{"IDColumn"}\NormalTok{]]}
\NormalTok{                ),}
                \KeywordTok{selectInput}\NormalTok{(}\KeywordTok{paste0}\NormalTok{(panel_name, }\StringTok{"_IDType"}\NormalTok{),}
                    \DataTypeTok{label=}\StringTok{"ID type:"}\NormalTok{,}
                    \DataTypeTok{choices=}\NormalTok{allowable,}
                    \DataTypeTok{selected=}\NormalTok{x[[}\StringTok{"IDType"}\NormalTok{]]}
\NormalTok{                ),}
                \KeywordTok{selectInput}\NormalTok{(}\KeywordTok{paste0}\NormalTok{(panel_name, }\StringTok{"_Organism"}\NormalTok{),}
                    \DataTypeTok{label=}\StringTok{"Organism"}\NormalTok{,}
                    \DataTypeTok{choices=}\KeywordTok{c}\NormalTok{(}\StringTok{"org.Hs.eg.db"}\NormalTok{, }\StringTok{"org.Mm.eg.db"}\NormalTok{),}
                    \DataTypeTok{selected=}\NormalTok{x[[}\StringTok{"Organism"}\NormalTok{]]}
\NormalTok{                )}
\NormalTok{            )}
\NormalTok{        ),}
        \KeywordTok{callNextMethod}\NormalTok{()}
\NormalTok{    ) }
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

\hypertarget{creating-the-observers}{%
\section{Creating the observers}\label{creating-the-observers}}

We specialize \texttt{.createObservers} to define some observers to respond to changes in our new interface elements.
Note the use of \texttt{callNextMethod()} to ensure that observers of the parent class are also created.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setMethod}\NormalTok{(}\StringTok{".createObservers"}\NormalTok{, }\StringTok{"GeneAnnoTable"}\NormalTok{,}
    \ControlFlowTok{function}\NormalTok{(x, se, input, session, pObjects, rObjects)}
\NormalTok{\{}
    \KeywordTok{callNextMethod}\NormalTok{()}

\NormalTok{    plot_name <-}\StringTok{ }\KeywordTok{.getEncodedName}\NormalTok{(x)}

    \KeywordTok{.createUnprotectedParameterObservers}\NormalTok{(plot_name,}
        \DataTypeTok{fields=}\KeywordTok{c}\NormalTok{(}\StringTok{"IDColumn"}\NormalTok{, }\StringTok{"Organism"}\NormalTok{, }\StringTok{"IDType"}\NormalTok{), }
        \DataTypeTok{input=}\NormalTok{input, }\DataTypeTok{pObjects=}\NormalTok{pObjects, }\DataTypeTok{rObjects=}\NormalTok{rObjects)}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

We need to set up a rendering expression for the annotation element that responds to the selected gene.
By using \texttt{.trackSingleSelection()}, we ensure that this UI element updates in response to changes in the table selection.
We add a series of protective measures to avoid the application crashing due to missing organism packages or unmatched IDs.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setMethod}\NormalTok{(}\StringTok{".renderOutput"}\NormalTok{, }\StringTok{"GeneAnnoTable"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x, se, ..., output, pObjects, rObjects) \{}
    \KeywordTok{callNextMethod}\NormalTok{() }\CommentTok{# Re-using RowDataTable's output rendering.}

\NormalTok{    panel_name <-}\StringTok{ }\KeywordTok{.getEncodedName}\NormalTok{(x)}
\NormalTok{    output[[}\KeywordTok{paste0}\NormalTok{(panel_name, }\StringTok{"_annotation"}\NormalTok{)]] <-}\StringTok{ }\KeywordTok{renderUI}\NormalTok{(\{}
        \KeywordTok{.trackSingleSelection}\NormalTok{(panel_name, rObjects)}
\NormalTok{        instance <-}\StringTok{ }\NormalTok{pObjects}\OperatorTok{$}\NormalTok{memory[[panel_name]]}

\NormalTok{        rowdata_col <-}\StringTok{ }\NormalTok{instance[[}\StringTok{"IDColumn"}\NormalTok{]]}
\NormalTok{        selectedGene <-}\StringTok{ }\NormalTok{instance[[}\StringTok{"Selected"}\NormalTok{]]}
        \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(rowdata_col)) \{}
\NormalTok{            selectedGene <-}\StringTok{ }\KeywordTok{rowData}\NormalTok{(se)[selectedGene,rowdata_col]}
\NormalTok{        \}}

\NormalTok{        keytype <-}\StringTok{ }\NormalTok{instance[[}\StringTok{"IDType"}\NormalTok{]]}
\NormalTok{        selgene_entrez <-}\StringTok{ }\OtherTok{NA}
        \ControlFlowTok{if}\NormalTok{ (keytype}\OperatorTok{!=}\StringTok{"ENTREZID"}\NormalTok{) \{}
\NormalTok{            ORG <-}\StringTok{ }\NormalTok{instance[[}\StringTok{"Organism"}\NormalTok{]]}
            \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{require}\NormalTok{(ORG, }\DataTypeTok{character.only=}\OtherTok{TRUE}\NormalTok{, }\DataTypeTok{quietly=}\OtherTok{TRUE}\NormalTok{)) \{}
\NormalTok{                orgdb <-}\StringTok{ }\KeywordTok{get}\NormalTok{(ORG)}
\NormalTok{                selgene_entrez <-}\StringTok{ }\KeywordTok{try}\NormalTok{(}\KeywordTok{mapIds}\NormalTok{(orgdb, selectedGene, }\StringTok{"ENTREZID"}\NormalTok{, keytype), }
                    \DataTypeTok{silent=}\OtherTok{TRUE}\NormalTok{)}
\NormalTok{            \}}
\NormalTok{        \} }\ControlFlowTok{else}\NormalTok{ \{}
\NormalTok{            selgene_entrez <-}\StringTok{ }\NormalTok{selectedGene}
\NormalTok{        \}}

        \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{is.na}\NormalTok{(selgene_entrez) }\OperatorTok{||}\StringTok{ }\KeywordTok{is}\NormalTok{(selgene_entrez, }\StringTok{"try-error"}\NormalTok{)) \{}
            \KeywordTok{return}\NormalTok{(}\OtherTok{NULL}\NormalTok{)}
\NormalTok{        \}}

\NormalTok{        fullinfo <-}\StringTok{ }\NormalTok{rentrez}\OperatorTok{::}\KeywordTok{entrez_summary}\NormalTok{(}\StringTok{"gene"}\NormalTok{, selgene_entrez)}
\NormalTok{        link_pubmed <-}\StringTok{ }\KeywordTok{paste0}\NormalTok{(}\StringTok{'<a href="http://www.ncbi.nlm.nih.gov/gene/?term='}\NormalTok{,}
\NormalTok{            selgene_entrez,}
            \StringTok{'" target="_blank">Click here to see more at the NCBI database</a>'}\NormalTok{)}

\NormalTok{        mycontent <-}\StringTok{ }\KeywordTok{paste0}\NormalTok{(}\StringTok{"<b>"}\NormalTok{,fullinfo}\OperatorTok{$}\NormalTok{name, }\StringTok{"</b><br/><br/>"}\NormalTok{,}
\NormalTok{            fullinfo}\OperatorTok{$}\NormalTok{description,}\StringTok{"<br/><br/>"}\NormalTok{,}
            \KeywordTok{ifelse}\NormalTok{(fullinfo}\OperatorTok{$}\NormalTok{summary }\OperatorTok{==}\StringTok{ ""}\NormalTok{,}\StringTok{""}\NormalTok{,}\KeywordTok{paste0}\NormalTok{(fullinfo}\OperatorTok{$}\NormalTok{summary, }\StringTok{"<br/><br/>"}\NormalTok{)),}
\NormalTok{            link_pubmed)}

        \KeywordTok{HTML}\NormalTok{(mycontent)}
\NormalTok{    \})}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

Observant readers will note that the body of the rendering expression uses \texttt{pObjects\$memory{[}{[}panel\_name{]}{]}} rather than \texttt{x}.
This is intentional as it ensures that we are using the parameter settings from the current state of the app.
If we used \texttt{x}, we would always be using the parameters from the initial state of the app, which is not what we want.

\hypertarget{in-action}{%
\section{In action}\label{in-action}}

Let's put our new panel to the test using the \texttt{sce} object from Chapter \ref{developing}.
We set up our \texttt{iSEE} instance such that clicking on any row will bring up the Entrez annotation (if available) for that feature.
It is probably best to click on some well-annotated genes as the set of RIKEN transcripts at the front don't have much annotation.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{gat <-}\StringTok{ }\KeywordTok{GeneAnnoTable}\NormalTok{(}\DataTypeTok{PanelWidth=}\NormalTok{8L, }\DataTypeTok{Selected=}\StringTok{"Snap25"}\NormalTok{, }\DataTypeTok{Search=}\StringTok{"Snap"}\NormalTok{)}
\NormalTok{app <-}\StringTok{ }\KeywordTok{iSEE}\NormalTok{(sce, }\DataTypeTok{initial=}\KeywordTok{list}\NormalTok{(gat))}
\end{Highlighting}
\end{Shaded}

\includegraphics[width=1\linewidth]{screenshots/anno-table}

\hypertarget{gene-ontology-table}{%
\chapter{Gene ontology table}\label{gene-ontology-table}}

\hypertarget{overview}{%
\section{Overview}\label{overview}}

Here, we will construct a table of GO terms where selection of a row in the table
causes transmission of a multiple selection of gene names.
The aim is to enable us to transmit multiple row selections to other panels based on their membership of a gene set.
This is a fairly involved example of creating a \texttt{Panel} subclass as we cannot easily inherit from an existing subclass; rather, we need to provide all the methods ourselves.
Readers may also be interested in the fully fledged version of the proposed class in \emph{\href{https://bioconductor.org/packages/3.12/iSEEu}{iSEEu}}.

\hypertarget{class-basics}{%
\section{Class basics}\label{class-basics}}

First, we define the basics of our new \texttt{GOTable} class.
This inherits from the virtual base \texttt{Panel} class as its behavior is not compatible with any of the existing subclasses,
what with the \texttt{DataTable} selection event triggering a multiple selection rather than a single selection.
We add some slots to specify the feature ID type and the organism of interest as well as for \texttt{DataTable} parameters.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(iSEE)}
\KeywordTok{library}\NormalTok{(S4Vectors)}
\KeywordTok{setClass}\NormalTok{(}\StringTok{"GOTable"}\NormalTok{, }\DataTypeTok{contains=}\StringTok{"Panel"}\NormalTok{,}
    \DataTypeTok{slots=}\KeywordTok{c}\NormalTok{(}
        \DataTypeTok{IDType=}\StringTok{"character"}\NormalTok{,}
        \DataTypeTok{Organism=}\StringTok{"character"}\NormalTok{,}
        \DataTypeTok{Selected=}\StringTok{"character"}\NormalTok{,}
        \DataTypeTok{Search=}\StringTok{"character"}\NormalTok{,}
        \DataTypeTok{SearchColumns=}\StringTok{"character"}
\NormalTok{    )}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

We also add some checks for these parameters.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{allowable.ids <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"ENSEMBL"}\NormalTok{, }\StringTok{"SYMBOL"}\NormalTok{, }\StringTok{"ENTREZID"}\NormalTok{)}
\NormalTok{allowable.org <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"org.Mm.eg.db"}\NormalTok{, }\StringTok{"org.Hs.eg.db"}\NormalTok{)}

\KeywordTok{setValidity2}\NormalTok{(}\StringTok{"GOTable"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(object) \{}
\NormalTok{    msg <-}\StringTok{ }\KeywordTok{character}\NormalTok{(}\DecValTok{0}\NormalTok{)}

\NormalTok{    msg <-}\StringTok{ }\KeywordTok{.allowableChoiceError}\NormalTok{(msg, object, }\StringTok{"Organism"}\NormalTok{, allowable.org)}

\NormalTok{    msg <-}\StringTok{ }\KeywordTok{.allowableChoiceError}\NormalTok{(msg, object, }\StringTok{"IDType"}\NormalTok{, allowable.ids)}

\NormalTok{    msg <-}\StringTok{ }\KeywordTok{.singleStringError}\NormalTok{(msg, object, }\KeywordTok{c}\NormalTok{(}\StringTok{"Selected"}\NormalTok{, }\StringTok{"Search"}\NormalTok{))}
    
    \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{length}\NormalTok{(msg)) \{}
        \KeywordTok{return}\NormalTok{(msg)}
\NormalTok{    \}}
    \OtherTok{TRUE}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

We then specialize the \texttt{initialize()} method to set reasonable defaults and create an approprpiate constructor.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setMethod}\NormalTok{(}\StringTok{"initialize"}\NormalTok{, }\StringTok{"GOTable"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(.Object, }
    \DataTypeTok{Organism=}\StringTok{"org.Mm.eg.db"}\NormalTok{, }\DataTypeTok{IDType=}\StringTok{"SYMBOL"}\NormalTok{, }
    \DataTypeTok{Selected=}\StringTok{""}\NormalTok{, }\DataTypeTok{Search=}\StringTok{""}\NormalTok{, }\DataTypeTok{SearchColumns=}\KeywordTok{character}\NormalTok{(}\DecValTok{0}\NormalTok{), ...)}
\NormalTok{\{}
    \KeywordTok{callNextMethod}\NormalTok{(.Object, }\DataTypeTok{IDType=}\NormalTok{IDType, }\DataTypeTok{Organism=}\NormalTok{Organism, }
        \DataTypeTok{Selected=}\NormalTok{Selected, }\DataTypeTok{Search=}\NormalTok{Search, }
        \DataTypeTok{SearchColumns=}\NormalTok{SearchColumns, ...)}
\NormalTok{\})}

\NormalTok{GOTable <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(...) }\KeywordTok{new}\NormalTok{(}\StringTok{"GOTable"}\NormalTok{, ...)}
\end{Highlighting}
\end{Shaded}

\hypertarget{setting-up-the-interface}{%
\section{Setting up the interface}\label{setting-up-the-interface}}

We define the full name and desired default color for display purposes:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setMethod}\NormalTok{(}\StringTok{".fullName"}\NormalTok{, }\StringTok{"GOTable"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x) }\StringTok{"Gene ontology table"}\NormalTok{)}

\KeywordTok{setMethod}\NormalTok{(}\StringTok{".panelColor"}\NormalTok{, }\StringTok{"GOTable"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x) }\StringTok{"#BB00FF"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

We add our UI element for showing the gene set table, which is simply a \texttt{DataTable} object from the \emph{\href{https://CRAN.R-project.org/package=DT}{DT}} package.
Note that \emph{\href{https://CRAN.R-project.org/package=shiny}{shiny}} also has a \texttt{dataTableOutput} function that is almost-but-not-quite-the-same so care must be taken to disambiguate them if both symbols are imported.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setMethod}\NormalTok{(}\StringTok{".defineOutput"}\NormalTok{, }\StringTok{"GOTable"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x, ...) \{}
\NormalTok{    panel_name <-}\StringTok{ }\KeywordTok{.getEncodedName}\NormalTok{(x)}
    \KeywordTok{tagList}\NormalTok{(DT}\OperatorTok{::}\KeywordTok{dataTableOutput}\NormalTok{(panel_name))}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

We set up interface elements for changing the annotation parameters.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setMethod}\NormalTok{(}\StringTok{".defineDataInterface"}\NormalTok{, }\StringTok{"GOTable"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x, se, select_info) \{}
\NormalTok{    panel_name <-}\StringTok{ }\KeywordTok{.getEncodedName}\NormalTok{(x)}
    \KeywordTok{list}\NormalTok{(}
        \KeywordTok{selectInput}\NormalTok{(}\KeywordTok{paste0}\NormalTok{(panel_name, }\StringTok{"_IDType"}\NormalTok{),}
            \DataTypeTok{label=}\StringTok{"ID type:"}\NormalTok{,}
            \DataTypeTok{choices=}\NormalTok{allowable.ids,}
            \DataTypeTok{selected=}\NormalTok{x[[}\StringTok{"IDType"}\NormalTok{]]}
\NormalTok{        ),}
        \KeywordTok{selectInput}\NormalTok{(}\KeywordTok{paste0}\NormalTok{(panel_name, }\StringTok{"_Organism"}\NormalTok{),}
            \DataTypeTok{label=}\StringTok{"Organism"}\NormalTok{,}
            \DataTypeTok{choices=}\NormalTok{allowable.org,}
            \DataTypeTok{selected=}\NormalTok{x[[}\StringTok{"Organism"}\NormalTok{]]}
\NormalTok{        )}
\NormalTok{    )}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

Our implementation will be a pure transmitter, i.e., it will not respond to row or column selections from other panels.
To avoid confusion, we can hide all selection-related UI elements by specializing the \texttt{.hideInterface()} method:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setMethod}\NormalTok{(}\StringTok{".hideInterface"}\NormalTok{, }\StringTok{"GOTable"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x, field) \{}
    \ControlFlowTok{if}\NormalTok{ (field }\OperatorTok{%in%}\StringTok{ "SelectionBoxOpen"}\NormalTok{) \{}
        \OtherTok{TRUE}
\NormalTok{    \} }\ControlFlowTok{else}\NormalTok{ \{}
        \KeywordTok{callNextMethod}\NormalTok{()}
\NormalTok{    \}}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

\hypertarget{generating-the-output}{%
\section{Generating the output}\label{generating-the-output}}

We generate the output by specializing the \texttt{.generateOutput()} function, using the \emph{\href{https://bioconductor.org/packages/3.12/GO.db}{GO.db}} package to create a table of GO terms and their definitions.
We also store the number of available genes in the \texttt{contents} - this will be used later to compute the percentage of all genes in a given gene set.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setMethod}\NormalTok{(}\StringTok{".generateOutput"}\NormalTok{, }\StringTok{"GOTable"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x, se, ..., all_memory, all_contents) \{}
\NormalTok{    envir <-}\StringTok{ }\KeywordTok{new.env}\NormalTok{()}
\NormalTok{    commands <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"require(GO.db);"}\NormalTok{,}
        \StringTok{"tab <- select(GO.db, keys=keys(GO.db), columns='TERM');"}\NormalTok{,}
        \StringTok{"rownames(tab) <- tab$GOID;"}\NormalTok{,}
        \StringTok{"tab$GOID <- NULL;"}\NormalTok{)}
    \KeywordTok{eval}\NormalTok{(}\KeywordTok{parse}\NormalTok{(}\DataTypeTok{text=}\NormalTok{commands), }\DataTypeTok{envir=}\NormalTok{envir)}
    \KeywordTok{list}\NormalTok{(}
        \DataTypeTok{commands=}\KeywordTok{list}\NormalTok{(commands), }
        \DataTypeTok{contents=}\KeywordTok{list}\NormalTok{(}\DataTypeTok{table=}\NormalTok{envir}\OperatorTok{$}\NormalTok{tab, }\DataTypeTok{available=}\KeywordTok{nrow}\NormalTok{(se)),}
        \DataTypeTok{varname=}\StringTok{"tab"}
\NormalTok{    )}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

We don't actually depend on any parameters of \texttt{x} itself to generate this table.
However, one could imagine a more complex case where the \texttt{GOTable} itself responds to a multiple row selection,
e.g., by subsetting to the gene sets that contain genes in the selected row.

\hypertarget{creating-the-observers}{%
\section{Creating the observers}\label{creating-the-observers}}

We specialize \texttt{.createObservers} to define some observers to respond to changes in our new interface elements.
This also involves creating an observer to respond to a change in the selection of a \texttt{DataTable} row,
calling \texttt{.requestActiveSelectionUpdate()} to trigger changes in panels that are receiving the multiple row selection.
(We set up observers for the search fields as well, as a courtesy to restore them properly upon any re-rendering that might occur.)

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setMethod}\NormalTok{(}\StringTok{".createObservers"}\NormalTok{, }\StringTok{"GOTable"}\NormalTok{,}
    \ControlFlowTok{function}\NormalTok{(x, se, input, session, pObjects, rObjects)}
\NormalTok{\{}
    \KeywordTok{callNextMethod}\NormalTok{()}

\NormalTok{    panel_name <-}\StringTok{ }\KeywordTok{.getEncodedName}\NormalTok{(x)}

    \KeywordTok{.createUnprotectedParameterObservers}\NormalTok{(panel_name,}
        \DataTypeTok{fields=}\KeywordTok{c}\NormalTok{(}\StringTok{"Organism"}\NormalTok{, }\StringTok{"IDType"}\NormalTok{), }
        \DataTypeTok{input=}\NormalTok{input, }\DataTypeTok{pObjects=}\NormalTok{pObjects, }\DataTypeTok{rObjects=}\NormalTok{rObjects)}

    \CommentTok{# Observer for the DataTable row selection:}
\NormalTok{    select_field <-}\StringTok{ }\KeywordTok{paste0}\NormalTok{(panel_name, }\StringTok{"_rows_selected"}\NormalTok{)}
\NormalTok{    multi_name <-}\StringTok{ }\KeywordTok{paste0}\NormalTok{(panel_name, }\StringTok{"_"}\NormalTok{, iSEE}\OperatorTok{:::}\NormalTok{.flagMultiSelect)}
    \KeywordTok{observeEvent}\NormalTok{(input[[select_field]], \{}
\NormalTok{        chosen <-}\StringTok{ }\NormalTok{input[[select_field]]}
        \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{length}\NormalTok{(chosen)}\OperatorTok{==}\NormalTok{0L) \{}
\NormalTok{            chosen <-}\StringTok{ ""} 
\NormalTok{        \} }\ControlFlowTok{else}\NormalTok{ \{}
\NormalTok{            chosen <-}\StringTok{ }\KeywordTok{rownames}\NormalTok{(pObjects}\OperatorTok{$}\NormalTok{contents[[panel_name]]}\OperatorTok{$}\NormalTok{table)[chosen]}
\NormalTok{        \}}

\NormalTok{        previous <-}\StringTok{ }\NormalTok{pObjects}\OperatorTok{$}\NormalTok{memory[[panel_name]][[}\StringTok{"Selected"}\NormalTok{]]}
        \ControlFlowTok{if}\NormalTok{ (chosen}\OperatorTok{==}\NormalTok{previous) \{}
            \KeywordTok{return}\NormalTok{(}\OtherTok{NULL}\NormalTok{)}
\NormalTok{        \}}
\NormalTok{        pObjects}\OperatorTok{$}\NormalTok{memory[[panel_name]][[}\StringTok{"Selected"}\NormalTok{]] <-}\StringTok{ }\NormalTok{chosen}
        \KeywordTok{.requestActiveSelectionUpdate}\NormalTok{(panel_name, session, pObjects, rObjects, }\DataTypeTok{update_output=}\OtherTok{FALSE}\NormalTok{)}
\NormalTok{    \}, }\DataTypeTok{ignoreInit=}\OtherTok{TRUE}\NormalTok{, }\DataTypeTok{ignoreNULL=}\OtherTok{FALSE}\NormalTok{)}

    \CommentTok{# Observer for the search field:}
\NormalTok{    search_field <-}\StringTok{ }\KeywordTok{paste0}\NormalTok{(panel_name, }\StringTok{"_search"}\NormalTok{)}
    \KeywordTok{observeEvent}\NormalTok{(input[[search_field]], \{}
\NormalTok{        search <-}\StringTok{ }\NormalTok{input[[search_field]]}
        \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{identical}\NormalTok{(search, pObjects}\OperatorTok{$}\NormalTok{memory[[panel_name]][[}\StringTok{"Search"}\NormalTok{]])) \{}
            \KeywordTok{return}\NormalTok{(}\OtherTok{NULL}\NormalTok{)}
\NormalTok{        \}}
\NormalTok{        pObjects}\OperatorTok{$}\NormalTok{memory[[panel_name]][[}\StringTok{"Search"}\NormalTok{]] <-}\StringTok{ }\NormalTok{search}
\NormalTok{    \})}

    \CommentTok{# Observer for the column search fields:}
\NormalTok{    colsearch_field <-}\StringTok{ }\KeywordTok{paste0}\NormalTok{(panel_name, }\StringTok{"_search_columns"}\NormalTok{)}
    \KeywordTok{observeEvent}\NormalTok{(input[[colsearch_field]], \{}
\NormalTok{        search <-}\StringTok{ }\NormalTok{input[[colsearch_field]]}
        \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{identical}\NormalTok{(search, pObjects}\OperatorTok{$}\NormalTok{memory[[panel_name]][[}\StringTok{"SearchColumns"}\NormalTok{]])) \{}
            \KeywordTok{return}\NormalTok{(}\OtherTok{NULL}\NormalTok{)}
\NormalTok{        \}}
\NormalTok{        pObjects}\OperatorTok{$}\NormalTok{memory[[panel_name]][[}\StringTok{"SearchColumns"}\NormalTok{]] <-}\StringTok{ }\NormalTok{search}
\NormalTok{    \})}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

Note the use of \texttt{callNextMethod()} to ensure that observers of the parent class are created.
We also set \texttt{ignoreInit=TRUE} to avoid problems from \texttt{ignoreNULL=TRUE} when the observer is initialized before the table is rendered;
otherwise, the \texttt{NULL} selection prior to table rendering will wipe out any initial setting for the \texttt{Selected} slot.

We set up a rendering expression for the output table by specializing \texttt{.renderOutput()}.
This uses the \texttt{renderDataTable()} function from the \emph{\href{https://CRAN.R-project.org/package=DT}{DT}} package
(again, this has a similar-but-not-identical function in \emph{\href{https://CRAN.R-project.org/package=shiny}{shiny}}, so be careful which one you import.)
Some effort is involved in making sure that the output table responds to the memorized parameter values of our \texttt{GOTable} panel.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setMethod}\NormalTok{(}\StringTok{".renderOutput"}\NormalTok{, }\StringTok{"GOTable"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x, se, ..., output, pObjects, rObjects) \{}
    \KeywordTok{callNextMethod}\NormalTok{()}

\NormalTok{    panel_name <-}\StringTok{ }\KeywordTok{.getEncodedName}\NormalTok{(x)}
\NormalTok{    output[[panel_name]] <-}\StringTok{ }\NormalTok{DT}\OperatorTok{::}\KeywordTok{renderDataTable}\NormalTok{(\{}
\NormalTok{        t.out <-}\StringTok{ }\KeywordTok{.retrieveOutput}\NormalTok{(panel_name, se, pObjects, rObjects)}
\NormalTok{        full_tab <-}\StringTok{ }\NormalTok{t.out}\OperatorTok{$}\NormalTok{contents}\OperatorTok{$}\NormalTok{table}

\NormalTok{        param_choices <-}\StringTok{ }\NormalTok{pObjects}\OperatorTok{$}\NormalTok{memory[[panel_name]]}
\NormalTok{        chosen <-}\StringTok{ }\NormalTok{param_choices[[}\StringTok{"Selected"}\NormalTok{]]}
\NormalTok{        search <-}\StringTok{ }\NormalTok{param_choices[[}\StringTok{"Search"}\NormalTok{]]}
\NormalTok{        search_col <-}\StringTok{ }\NormalTok{param_choices[[}\StringTok{"SearchColumns"}\NormalTok{]]}
\NormalTok{        search_col <-}\StringTok{ }\KeywordTok{lapply}\NormalTok{(search_col, }\DataTypeTok{FUN=}\ControlFlowTok{function}\NormalTok{(x) \{ }\KeywordTok{list}\NormalTok{(}\DataTypeTok{search=}\NormalTok{x) \})}

        \CommentTok{# If the existing row in memory doesn't exist in the current table, we}
        \CommentTok{# don't initialize it with any selection.}
\NormalTok{        idx <-}\StringTok{ }\KeywordTok{which}\NormalTok{(}\KeywordTok{rownames}\NormalTok{(full_tab)}\OperatorTok{==}\NormalTok{chosen)[}\DecValTok{1}\NormalTok{]}
        \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.na}\NormalTok{(idx)) \{}
\NormalTok{            selection <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}\DataTypeTok{mode=}\StringTok{"single"}\NormalTok{, }\DataTypeTok{selected=}\NormalTok{idx)}
\NormalTok{        \} }\ControlFlowTok{else}\NormalTok{ \{}
\NormalTok{            selection <-}\StringTok{ "single"}
\NormalTok{        \}}

\NormalTok{        DT}\OperatorTok{::}\KeywordTok{datatable}\NormalTok{(}
\NormalTok{            full_tab, }\DataTypeTok{filter=}\StringTok{"top"}\NormalTok{, }\DataTypeTok{rownames=}\OtherTok{TRUE}\NormalTok{,}
            \DataTypeTok{options=}\KeywordTok{list}\NormalTok{(}
                \DataTypeTok{search=}\KeywordTok{list}\NormalTok{(}\DataTypeTok{search=}\NormalTok{search, }\DataTypeTok{smart=}\OtherTok{FALSE}\NormalTok{, }\DataTypeTok{regex=}\OtherTok{TRUE}\NormalTok{, }\DataTypeTok{caseInsensitive=}\OtherTok{FALSE}\NormalTok{),}
                \DataTypeTok{searchCols=}\KeywordTok{c}\NormalTok{(}\KeywordTok{list}\NormalTok{(}\OtherTok{NULL}\NormalTok{), search_col), }\CommentTok{# row names are the first column!}
                \DataTypeTok{scrollX=}\OtherTok{TRUE}\NormalTok{),}
            \DataTypeTok{selection=}\NormalTok{selection}
\NormalTok{        )}
\NormalTok{    \})}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

\hypertarget{handling-selections}{%
\section{Handling selections}\label{handling-selections}}

Now for the most important bit - configuring the \texttt{GOTable} to transmit a multiple row selection to other panels.
This is achieved by specializing a series of \texttt{.multiSelection*()} methods.
The first is the \texttt{.multiSelectionDimension()}, which controls the dimension being transmitted:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setMethod}\NormalTok{(}\StringTok{".multiSelectionDimension"}\NormalTok{, }\StringTok{"GOTable"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x) }\StringTok{"row"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

The next most important method is the \texttt{.multiSelectionCommands()}, which tells \texttt{iSEE()} how to create the multiple row selection from the selected \texttt{DataTable} row.
It is expected to return a vector of commands that, when evaluated, creates a character vector of row names for transmission.
This has an option (\texttt{index}) to differentiate between active and saved selections, though the latter case is not relevant to our \texttt{GOTable} so we will simply ignore it.
We also need to protect against cases where the requested GO term is not found, upon which we simply return an empty character vector.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setMethod}\NormalTok{(}\StringTok{".multiSelectionCommands"}\NormalTok{, }\StringTok{"GOTable"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x, index) \{}
\NormalTok{    orgdb <-}\StringTok{ }\NormalTok{x[[}\StringTok{"Organism"}\NormalTok{]]}
\NormalTok{    type <-}\StringTok{ }\NormalTok{x[[}\StringTok{"IDType"}\NormalTok{]]}
    \KeywordTok{c}\NormalTok{(}
        \KeywordTok{sprintf}\NormalTok{(}\StringTok{"require(%s);"}\NormalTok{, orgdb),}
        \KeywordTok{sprintf}\NormalTok{(}\StringTok{"selected <- tryCatch(select(%s, keys=%s, keytype='GO', }
\StringTok{    column=%s)$SYMBOL, error=function(e) character(0));"}\NormalTok{, }
\NormalTok{            orgdb, }\KeywordTok{deparse}\NormalTok{(x[[}\StringTok{"Selected"}\NormalTok{]]), }\KeywordTok{deparse}\NormalTok{(type)),}
        \StringTok{"selected <- intersect(selected, rownames(se));"}
\NormalTok{    )}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

We also define some generics to indicate whether a \texttt{DataTable} row is currently selected, and how to delete that selection.
For the latter, we replace the selected row with an empty string to indicate that no selection has been made,
consistent with the actions of our observer in \texttt{.createObservers()}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setMethod}\NormalTok{(}\StringTok{".multiSelectionActive"}\NormalTok{, }\StringTok{"GOTable"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x) \{}
    \ControlFlowTok{if}\NormalTok{ (x[[}\StringTok{"Selected"}\NormalTok{]]}\OperatorTok{!=}\StringTok{""}\NormalTok{) \{}
\NormalTok{        x[[}\StringTok{"Selected"}\NormalTok{]]}
\NormalTok{    \} }\ControlFlowTok{else}\NormalTok{ \{}
        \OtherTok{NULL}
\NormalTok{    \}}
\NormalTok{\})}

\KeywordTok{setMethod}\NormalTok{(}\StringTok{".multiSelectionClear"}\NormalTok{, }\StringTok{"GOTable"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x) \{}
\NormalTok{    x[[}\StringTok{"Selected"}\NormalTok{]] <-}\StringTok{ ""}
\NormalTok{    x}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

Finally, we define a method to determine the total number of available genes.
This is done by returning the availability information that we previously stored in the \texttt{contents} during \texttt{.generateOutput()}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setMethod}\NormalTok{(}\StringTok{".multiSelectionAvailable"}\NormalTok{, }\StringTok{"GOTable"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x, contents) \{}
\NormalTok{    contents}\OperatorTok{$}\NormalTok{available}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

\hypertarget{in-action}{%
\section{In action}\label{in-action}}

Let's put our new panel to the test using the \texttt{sce} object from Chapter \ref{developing}.
We set up an \texttt{iSEE} instance where clicking on any row in the \texttt{GOTable} will subset \texttt{RowTable1} to only those genes in the corresponding GO term.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{got <-}\StringTok{ }\KeywordTok{GOTable}\NormalTok{(}\DataTypeTok{PanelWidth=}\NormalTok{8L, }\DataTypeTok{Selected=}\StringTok{"GO:0007049"}\NormalTok{, }\DataTypeTok{Search=}\StringTok{"^cell cycle"}\NormalTok{)}
\NormalTok{rst <-}\StringTok{ }\KeywordTok{RowDataTable}\NormalTok{(}\DataTypeTok{RowSelectionSource=}\StringTok{"GOTable1"}\NormalTok{)}
\NormalTok{app <-}\StringTok{ }\KeywordTok{iSEE}\NormalTok{(sce, }\DataTypeTok{initial=}\KeywordTok{list}\NormalTok{(got, rst))}
\end{Highlighting}
\end{Shaded}

\includegraphics[width=1\linewidth]{screenshots/go-table}

\hypertarget{part-appendix}{%
\part{Appendix}\label{part-appendix}}

\hypertarget{contributors}{%
\chapter{Contributors}\label{contributors}}

\hypertarget{aaron-lun}{%
\subsection*{\texorpdfstring{\emph{Aaron Lun}}{Aaron Lun}}\label{aaron-lun}}
\addcontentsline{toc}{subsection}{\emph{Aaron Lun}}

187 days of anime watched.
Nuff said.

\hypertarget{kevin-rue-albrecht}{%
\subsection*{\texorpdfstring{\emph{Kevin Rue-Albrecht}}{Kevin Rue-Albrecht}}\label{kevin-rue-albrecht}}
\addcontentsline{toc}{subsection}{\emph{Kevin Rue-Albrecht}}

Je n'en crois pas mes yeux!

  \bibliography{book.bib,packages.bib}

\end{document}
