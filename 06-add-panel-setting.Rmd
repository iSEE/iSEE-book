# Adding panel settings {#add-panel-setting}

## Create a slot

We define slot names and the type of value that they expect.

Here the slot will contains a character vector that includes keywords indicating the dimensions (i.e., row, column) for which names should be displayed.

```{r, eval=FALSE}
collated <- character(0)
.showDimnames <- "ShowDimNames"
collated[.showDimnames] <- "character"
# ... other slots ...
#' @export
setClass("ComplexHeatmapPlot", contains="Panel", slots=collated)
```

## Define new constants (optional)

If the panel setting involves a set of predefined choices - as opposed to dynamic sets choices that depend on the dataset such as feature names -, we may need to declare those predefined choices as constants.

We define two keywords that will be used to label corresponding checkboxes in the GUI.

```{r, eval=FALSE}
.showNamesRowTitle <- "Row"
.showNamesColumnTitle <- "Column"
```

## Initialize setting with a default value

In the `initialize` function, we set the default setting to include both keywords.
This indicates that the heatmap should display both row and column names.

```{r, eval=FALSE}
#' @export
#' @importFrom methods callNextMethod
setMethod("initialize", "ComplexHeatmapPlot", function(.Object, ...) {
    args <- list(...)

    # ... other slots ...
    args <- .empty_default(args, .showDimnames, c(.showNamesRowTitle, .showNamesColumnTitle))

    do.call(callNextMethod, c(list(.Object), args))
})
```

## Add UI elements

In the `.defineInterface` - or typically in a subfunction - we define a UI element that displays the choices to the user.
Note how we use the slot names and the constants - in combination with the unique panel identifier - to create a unique and standardised identifier for the widget.

```{r, eval=FALSE}
plot_name <- .getEncodedName(x)
checkboxGroupInput(
    inputId=paste0(plot_name, "_", .showDimnames), label="Show names:", inline=TRUE,
    selected=x[[.showDimnames]],
    choices=c(.showNamesRowTitle, .showNamesColumnTitle))
```

## Add observers

We need to add observers watching the UI input, to trigger rerendering of the plot.
Conveniently, the `.createUnprotectedParameterObservers` takes care of the heavy-lifting for us.
The `fields` argument only needs to be given the list of fields to watch.
The function will then create observers watching the given fields for each panel instance of the class in the GUI.
Using the standardised naming of identifiers for input widget, the observers will take care of updating the corresponding slots of the appropriate panel instance.

```{r, eval=FALSE}
#' @export
setMethod(".createObservers", "ComplexHeatmapPlot", function(x, se, input, session, pObjects, rObjects) {
    callNextMethod()

    plot_name <- .getEncodedName(x)

    # ... other observers ....

    .createUnprotectedParameterObservers(plot_name,
        fields=c(.showDimnames),
        input=input, pObjects=pObjects, rObjects=rObjects)
})
```

## Update the plotting code

The `Heatmap` function of the `ComplexHeatmap` package has two separate arguments - `show_row_names` and `show_column_names` - each taking a logical value to toggle the visibility of row and column names, respectively.

In `.generateOutput`, when generating the code to draw the heatmap, we use the setting of the corresponding slot to check whether each of the keyword is present.

```{r, eval=FALSE}
show_row_names <- sprintf("show_row_names=%s", .showNamesRowTitle %in% x[[.showDimnames]])
show_column_names <- sprintf("show_column_names=%s", .showNamesColumnTitle %in% x[[.showDimnames]])
# ... process other settings ...
heatmap_args <- paste("", show_row_names, show_column_names, sep = ", ")
all_cmds[["heatmap"]] <- sprintf("hm <- Heatmap(matrix = plot.data%s)", heatmap_args)
```

Ultimately, this generates a command that looks like:

```{r, eval=FALSE}
hm <- Heatmap(matrix = plot.data, show_row_names=TRUE, show_column_names=FALSE)
```
