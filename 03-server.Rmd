# The app server {#server}

## Reactive objects {#robjects}

<!-- TODO
A general description of the purpose of reactive values in rObjects would probably be enough.
I don't think developers need details about each individual value.

Some examples values manually collected from iSEE-main.R:
- rerender
- rerendered
- paste0(mode, id)
- paste0(mode, id, "_", .panelLinkInfo)
- paste0(mode, id, "_", .panelGeneralInfo)
- paste0(mode, id, "_", .selectMultiSaved)
- paste0(mode, id, "_repopulated")
- paste0(mode, id, "_reactivated")
- paste0(mode, id, "_resaved")
-->

## Persistent (non-reactive) objects

<!-- TODO
A description of the purpose of pObjects.
In particular, memory and coordinates are key to highlight, although they will be described in further details in dedicated sections.

Some examples:
- memory
- counter
- commands
- coordinates
- cached_info
- .voiceActivePanel
-->

## The app memory {#memory}

The app `memory` is a list of instances created from available panel classes and currently visible in the GUI.
The order of panel instances in `memory` directly reflects their order in the GUI.

## Initialization of the app server

The app server is initialized as soon as a valid `se` object is provided.
This can be either in the call to `iSEE(se)` or using other mechanisms of data upload at runtime within the app (e.g., `fileInput` UI widgets when `iSEE()` is called without providing the `se` argument).

The internal function `iSEE:::.initialize_server()` takes the `se` object and the list holding reactive values used to trigger re-rendering of the GUI, as described in the section [Reactive objects](#robjects).

The very first step invokes the internal function `checkColormapCompatibility()`.
This function takes the `se` object and the optional argument `iSEE(colormap)`, and carries out a number of compatibility checks between the two objects.
The function collects a character vector of incompatibility issues that are displayed - if any - as warning notifications in GUI when the app is launched.

<!-- TODO: something about setting up memory, once the current TEST code is replaced. -->

Next, the internal function `iSEE:::.prepare_SE()` calls the method `.cacheCommonInfo()` on each type of panel present provided to the arguments `iSEE(initial)` and `iSEE(extra)`, to precompute and cache information relevant to all the types of panels that will be available in that app instance.

Shortly after, the internal function `iSEE:::.setup_initial_state()` calls the method `.refineParameters` on each panel instance provided to `iSEE(initial)`, to ensure that all the panels present in the GUI when the app is launched are initialized with valid parameters; any invalid parameter is replaced with sensible values for the given `se` object.

<!-- TODO: something about .define_reservoir -->

<!-- TODO: something, once we deal with user-supplied panel IDs -->

The internal function `iSEE:::.create_persistent_objects()` executes the initialization of persistent (non-reactive) objects:

- the app `memory` (see the section [The app memory](#memory))
- the app `reservoir`, which stores one instance of panel type available for this app instance
- the app `counter` is used to track the number of panels previously created for each type, and to assign an increasing identifier to new panel instances
- the app `commands` stores the list of code chunks to display in the code tracker, to reproduce each panel output
- the app `contents` stores the list of data point coordinates selectable in each panel instance^[Data points downsampled for rendering speed performance remain selectable, even though they are not visible in the plot.]
<!-- TODO: something about varname -->
<!-- TODO: something about aesthetics_links -->
<!-- TODO: something about selection_links -->
- the identifier of the panel under the control of speech recognition

<!-- TODO: something about rObjects -->

<!-- TODO: something about the various kinds of observers -->
